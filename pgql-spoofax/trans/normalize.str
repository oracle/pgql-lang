module normalize

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-

rules

  normalize-before:
    ast -> result
    with
      variable-counter := <new-counter>;
      bindVariable-counter := <new-counter>;
      error-messages := <
        (  is-pgql10; collect(get-pgql10-limitation)
        <+ is-pgql11; (collect(get-pgql11-limitation); not(?[]) <+ collect(get-pgql11-deprecation))
        <+ is-pgql12; collect(get-pgql12-deprecation); flatten-list
        )
        ; not(?[]) <+ get-path-limitations <+ ![]> ast;
      result := <
        alltd(norm-has-prop);
        alltd(norm-pgql10);
      	alltd(norm-BindVariable(|bindVariable-counter));
      	alltd(norm-UMin);
        innermost(
          norm-NOT +
          norm-NEQ +
          norm-singleVertex +
          norm-VertexWithoutBrackets +
          norm-inPredicate +
          norm-isNull +
          norm-case
        );
      	alltd(norm-edgeContents);
        ( (is-pgql10 + is-pgql11); alltd(norm-legacy-string-literal + norm-legacy-identifier) +
          is-pgql12; alltd(norm-string-literal + norm-identifier) +
          Start-Plhdr() // empty query string
        );
        alltd(norm-timezone);
        alltd(norm-datetime-literal);
        alltd(norm-hop-distance);
        alltd(name-unnamed-elems(|variable-counter));
        alltd(norm-inlined-references);
        bottomup(try(
           norm-matchElems(|variable-counter)
        ));
        bottomup(try(origin-track-forced(norm-query(|error-messages, variable-counter))));
        alltd(?ElemContents(Some(<id>), _, _, _))
      > ast

rules

  is-pgql10 = ?Pgql10Query(_, _, _, _, _, _, _)
  is-pgql11 = ?Pgql11Query(_, _, _, _, _, _, _, _, _)
  is-pgql12 = ?Query(_, _, _, _, _, _, _, _)

  get-pgql11-deprecation = (?OutConn(None(), _) + ?InConn(None(), _) + ?UndirectedEdge(None(), _)); to-error-message(|"Use [-] instead of [--]")
  get-pgql11-deprecation = ?Pgql10AsignSymbol(); to-error-message(|"Use [AS] instead of [:=]")
  get-pgql11-deprecation = ?Legacy10Label(_); to-error-message(|"Use [label(x)] instead of [x.label()]")
  get-pgql11-deprecation = ?Legacy10Labels(_); to-error-message(|"Use [labels(x)] instead of [x.labels()]")
  get-pgql11-deprecation = ?Legacy10HasLabel(_, _); to-error-message(|"Use [has_label(x, 'lbl')] instead of [x.hasLabel('lbl')]")
  get-pgql11-deprecation = ?Legacy10Id(_); to-error-message(|"Use [id(x)] instead of [x.id()]")
  get-pgql11-deprecation = ?Legacy10Has(_, _); to-error-message(|"Use [x.prop IS NOT NULL] instead of [x.has(prop)]")
  get-pgql11-deprecation = ?Legacy10InDegree(_); to-error-message(|"Use [in_degree(x)] instead of [x.indegree()]")
  get-pgql11-deprecation = ?Legacy10OutDegree(_); to-error-message(|"Use [out_degree(x)] instead of [x.out_degree()]")

  get-pgql11-deprecation = ?Legacy10Asc(x); to-error-message(|$<Use [<<origin-text> x> ASC] instead of [ASC(<<origin-text> x>)]>)
  get-pgql11-deprecation = ?Legacy10Desc(x); to-error-message(|$<Use [<<origin-text> x> DESC] instead of [DESC(<<origin-text> x>)]>)
  get-pgql11-deprecation = ?String(<id>); is-double-quoted; to-error-message(|"Use single quotes for character string literals; not double quotes")
  get-pgql11-deprecation = ?Legacy10Identifier(_); to-error-message(|"Use double quotes to delimit labels")
  get-pgql11-deprecation = ?Ids(_); to-error-message(|"Use [id(x) = xyz] instead of [@xyz]")
  get-pgql11-deprecation = ?InlinedConstraint(_); to-error-message(|"Constraints should be specified in the WHERE clause instead of the WITH")
  get-pgql11-deprecation = ?Legacy10Not(_); to-error-message(|"Use [NOT] instead of [!]")
  get-pgql11-deprecation = ?Legacy10Regex(_, _); to-error-message(|"Use [java_regexp_like(exp1, exp2)] instead of [exp1 =~ exp2]")

  get-pgql12-deprecation = get-pgql11-deprecation // inheriting all deprecations from 1.1

  get-pgql12-deprecation:
    GroupByClause(expAsVars) -> errors
    with errors := <filter(?ExpAsVar(_, Some(<id>))); map(to-error-message(|"Variable definition not allowed in GROUP BY"))> expAsVars

  get-pgql10-limitation = ( ?Pgql11FromClause(_)
                          + ?Subquery(_)
                          + ?Pgql11AsignSymbol()
                          + ?ExtractExp(_, _)
                          + ?ARRAY-AGG(_, _)
                          + ?Shortest(_, _)
                          + get-pgql11-limitation
                          )
                        ; to-error-message(|"Use [SELECT .. FROM MATCH( .. ) WHERE ..] or [SELECT .. FROM graphName MATCH( .. ) WHERE ..]")

  get-pgql11-limitation = fail // currently all PGQL 1.2 features are also supported in PGQL 1.1

  // TODO: move this to check.str (all the information should be in the normalized AST)
  get-path-limitations = collect(shortest-or-reaches + is-quantifier)
                           ; remove-all(shortest-or-reaches)
                           ; not(?[])
                           ; map(to-error-message(|"Quantifier needs to be enclosed by SHORTEST"))

  get-path-limitations = collect(?Shortest(_, _)); collect(?Path(_, _, _)); not(?[]); map(to-error-message(|"Nested regular expressions not yet supported"))

  shortest-or-reaches = ?Shortest(_, _)
                      + ?OutConn(Some(Path(_, _, _)), _)
                      + ?InConn(Some(Path(_, _, _)), _)

  norm-pgql10 = ?Legacy10Label(x); <to-function(|"label")> [x]
  norm-pgql10 = ?Legacy10Labels(x); <to-function(|"labels")> [x]
  norm-pgql10 = ?Legacy10HasLabel(x, lbl); <to-function(|"has_label")> [x, lbl]
  norm-pgql10 = ?Legacy10Id(x); <to-function(|"id")> [x]
  norm-pgql10 = ?Legacy10Has(x, prop); <to-function(|"has_prop")> [x, prop]
  norm-pgql10 = ?Legacy10InDegree(x); <to-function(|"in_degree")> [x]
  norm-pgql10 = ?Legacy10OutDegree(x); <to-function(|"out_degree")> [x]
  norm-pgql10 = ?Legacy10Regex(x, regex); <to-function(|"java_regexp_like")> [x, regex]

  to-function(|name):
    args -> FunctionCall(None(), name, args)

  norm-BindVariable(|c) = ?BindVariable(); !BindVariable(<next-counter> c)

  norm-UMin = ?UMin(Decimal(string)); !Decimal(<conc-strings> ("-", string))

  norm-NOT = ?Legacy10Not(<id>); !Not(<id>)

  norm-NEQ = ?Neq1(exp1, exp2); !Neq(exp1, exp2)
  norm-NEQ = ?Neq2(exp1, exp2); !Neq(exp1, exp2)

  norm-string-literal = String(un-single-quote; unescape-string-literal)
  unescape-string-literal = string-replace(|"''", "'")

  norm-identifier = Identifier(try(un-double-quote; unescape-delimited-identifier))
  unescape-delimited-identifier = string-replace(|"\"\"", "\"")

  norm-legacy-string-literal = String(unquote-and-unescape-legacy-string-literal)

  norm-legacy-identifier = Identifier(unquote-and-unescape-legacy-identifier)
                         + Legacy10Identifier(unquote-and-unescape-legacy-string-literal)

  unquote-and-unescape-legacy-string-literal = (is-single-quoted; un-single-quote; unescape-legacy-string-literal)
                                      + (is-double-quoted; un-double-quote; unescape-legacy-identifier) // legacy PGQL 1.0 string literal
  unquote-and-unescape-legacy-identifier = (is-double-quoted; un-double-quote; unescape-legacy-identifier) <+ id
  external unescape-legacy-string-literal(|)
  external unescape-legacy-identifier(|)

  norm-datetime-literal = Date(un-single-quote)
                        + Time(un-single-quote)
                        + Timestamp(un-single-quote)

  norm-timezone:
    Cast(exp, type) -> Cast(exp, type')
    with
      type' := <origin-track-forced(upper-case
              /* In standard SQL the time zone is denoted by "TIME ZONE" while in java.sql.* it's denoted by "TIMEZONE".
                 Clearly people have been confusing it. Therefore, we support both notations in PGQL by normalizing one
                 into the other. Users can then use either. However, please stick to TIME ZONE (with space) in
                 documentation to follow the standard. */
              ; string-replace(|"TIME ZONE", "TIMEZONE"))> type

  norm-inPredicate = ?InPredicate(exp1, Some(NOT()), exp2); origin-track-forced(!InPredicate(exp1, exp2)); !Not(<id>)
  norm-inPredicate = ?InPredicate(exp1, None(), exp2); origin-track-forced(!InPredicate(exp1, exp2))

  norm-isNull = ?IsNotNull(exp); origin-track-forced(!IsNull(exp)); !Not(<id>)

  norm-case:
    SimpleCase(caseOperand, whenClauses, elseClause) -> ifElse
    with ifElse := <to-if-else> (caseOperand, whenClauses, elseClause)

  to-if-else:
    (caseOperand, whenClauses, elseClause) -> IfElse(exp1, exp2, exp3)
    with [WhenClause(whenExp, thenExp)|xs] := whenClauses
       ; exp1 := Eq(caseOperand, whenExp)
       ; exp2 := thenExp
       ; if [] := xs
         then exp3 := <to-else> elseClause
         else exp3 := <to-if-else> (caseOperand, xs, elseClause)
         end

  norm-case:
    SearchedCase(whenClauses, elseClause) -> ifElse
    with ifElse := <to-if-else> (whenClauses, elseClause)

  to-if-else:
    (whenClauses, elseClause) -> IfElse(exp1, exp2, exp3)
    with [WhenClause(whenExp, thenExp)|xs] := whenClauses
       ; exp1 := whenExp
       ; exp2 := thenExp
       ; if [] := xs
         then exp3 := <to-else> elseClause
         else exp3 := <to-if-else> (xs, elseClause)
         end

  to-else = ?None(); !Null() <+ ?Some(ElseClause(<id>))

rules

  norm-singleVertex = ?SingleVertex(elemContents); !PathPattern(Vertex(elemContents), []) // SELECT * WHERE ()

  norm-VertexWithoutBrackets = ?VertexWithoutBrackets(v); !Vertex(ElemContents(Some(<origin-track-forced(<conc-strings> (v, <VERTEX_WITHOUT_BRACKETS>))>), None(), None(), None()))

  norm-edgeContents = ?Some(EdgeContents(<id>))

  name-unnamed-elems(|c) = (?CommonPathExpression(_, _, _, _) + ?GraphPattern(_)); alltd(name-unnamed-elem(|c))
  name-unnamed-elem(|c) = ?ElemContents(None(), type, id', constraints); ?origin; !ElemContents(Some(<unique-name(|c, origin)>), type, id', constraints)
  name-unnamed-elem(|c) = ?origin; (OutConn(?None(); name-unnamed-elem-helper(|c, origin), id) +
                           InConn(?None(); name-unnamed-elem-helper(|c, origin), id) +
                           UndirectedEdge(?None(); name-unnamed-elem-helper(|c, origin), id))
  name-unnamed-elem(|c) = ?OutEdge(quantifier); ?origin; !OutConn(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?InEdge(quantifier); ?origin; !InConn(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?UndirectedEdge(quantifier); ?origin; !UndirectedEdge(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?Path(None(), pathPatternRef, kleeneStar); ?origin; !Path(Some(<unique-name(|c, origin)>), pathPatternRef, kleeneStar)
  name-unnamed-elem-helper(|c, origin) = !ElemContents(Some(<unique-name(|c, origin)>), None(), None(), None())

  norm-inlined-references = ?ElemContents(Some(varName), _, _, _); alltd(norm-inlined-reference(|varName))
  norm-inlined-reference(|varName) =
    ?Obj(dot); !VarRef(varName) + (?Obj(VarRef(v), dot) + ?PropRef(VarRef(v), _));
    if <eq> (v, varName)
    then !ReferenceInInlinedConstraint(v)
    else !CrossReferenceInInlinedConstraint(v)
    end +
    (?SelfPropRef(propName) + ?SelfPropRef(dot, propName)); !PropRef(VarRef(varName), propName)

rules

  norm-matchElems(|variable-counter):
    GraphPattern(elems) -> GraphPattern(vertices, connections, constraints)
    with pathPatterns := <filter(?PathPattern(_, _) + ?Shortest(_, _))> elems
       // TODO: move below two statements to the end (also for common path expressions)
       ; inlined-constraints-for-vertices := <collect-outside-repeated-path(?Vertex(<id>))
                                           ; map(get-inlined-constraints); concat> pathPatterns
       ; inlined-constraints-for-edges := <collect-outside-repeated-path(?OutConn(<id>, None())
                                                                       + ?InConn(<id>, None())
                                                                       + ?UndirectedEdge(<id>, None()))
                                         ; filter(get-inlined-constraints); concat> pathPatterns
       ; vertices := <collect-outside-repeated-path(?Vertex(ElemContents(Some(<id>), _, _, _)); !Vertex(<id>)); !Vertices(<id>)> pathPatterns
       ; connections := <get-connections-from-paths(|variable-counter)> pathPatterns
       ; non-inlined-constraints := <filter(?CommonPathExpression(_, _, _, _) + ?Constraint(<id>)); remove-all(?CommonPathExpression(_, _, _, _))> elems
       ; constraints := <conc; flatten-list; !Constraints(<id>)> (inlined-constraints-for-vertices, inlined-constraints-for-edges, non-inlined-constraints)

  collect-outside-repeated-path(s) = collect-but-preserve-order(ParenthesizedPath + s); remove-all(ParenthesizedPath)

  collect-but-preserve-order(s) = collect-om(s, reverse-then-union); reverse // to preserve order of vertices

  reverse-then-union:
    (x, y) -> <union> (y, x)

  ParenthesizedPath = ?ParenthesizedPath(_, _, _, _, _)

  norm-common-path-expression(|variable-counter):
    CommonPathExpression(name, _, path, whereClause) -> CommonPathExpression(name, vertices, connections, constraints)
    with
      inlined-constraints-for-vertices := <collect-om(?Vertex(<id>)); map(get-inlined-constraints); concat> path;
      inlined-constraints-for-edges := <collect-om(?OutConn(<id>, _) + ?InConn(<id>, _) + ?UndirectedEdge(<id>, _)); filter(get-inlined-constraints); concat> path;
      non-inlined-constraints := <(?None(); ![]) <+ (?Some(WhereClause(<id>)); ![<id>])> whereClause;
      constraints := <concat; flatten-list; !Constraints(<id>)> [inlined-constraints-for-vertices, inlined-constraints-for-edges, non-inlined-constraints];
      vertices := <collect(?Vertex(_)); !Vertices(<id>)> path;
      connections := <get-connections-from-paths(|variable-counter)> [path]

  get-inlined-constraints:
    ElemContents(Some(var), label, id', otherConstraint) -> <concat> [labels, identifiers, otherConstraint']
    with labels := <?Some(Labels(<id>)); to-label-constraint(|var); ![<id>] <+ ![]> label
       ; identifiers := <?Some(Ids(<id>)); to-id-constraint(|var); ![<id>] <+ ![]> id'
       ; otherConstraint' := <?Some(InlinedConstraint(<id>)) <+ ![]> otherConstraint

  to-label-constraint(|var):
    labels ->  <to-hasLabel-expressions(|var)> labels
  to-hasLabel-expressions(|var) = bottomup(try(![VarRef(var), <to-label>]; to-function(|"has_label")))
  to-label = ?Label(<id>) + ?Legacy10Identifier(<id>); !Identifier(<id>) + ?BindVariable(_)
  to-id-constraint(|var) = bottomup(try(is-literal; origin-track-forced(!Eq(<to-function(|"id")> [VarRef(var)], <id>))))

  // base case: no paths
  get-connections-from-paths(|variable-counter):
    [] -> []

  // head is path with only one vertex => get neighbors for the other paths
  get-connections-from-paths(|variable-counter):
    [PathPattern(_, [])|otherPaths] -> <get-connections-from-paths(|variable-counter)> otherPaths

  // paths with more than one vertex
  get-connections-from-paths(|variable-counter):
    [pathPattern|otherPaths] -> <conc> (edges, edgesTailPaths)
    where not ( <?Shortest(_, _)> pathPattern)
    with kValue := "-1"
       ; edges := <pathPattern-to-connections(|variable-counter, kValue)> pathPattern
       ; edgesTailPaths := <get-connections-from-paths(|variable-counter)> otherPaths

  // paths with more than one vertex
  get-connections-from-paths(|variable-counter):
    [t@Shortest(
        kValue
      , pathPattern
      )|otherPaths] -> <conc> ([path'], edgesTailPaths)
    with kValue' := <?Some(TopK(<id>)) <+ !"1"> kValue
       ; edges := <pathPattern-to-connections(|variable-counter, kValue')> pathPattern
       ; path' := <?[single-path-only]; !single-path-only; try(single-edge-to-path(|variable-counter, kValue)) <+ !ComplexRegularExpressionNotSupported(<id>)> edges
       ; edgesTailPaths := <get-connections-from-paths(|variable-counter)> otherPaths

  single-edge-to-path(|variable-counter, kValue):
    edge@NormalizedEdge(srcVertex, e, dstVertex, direction, quantifier, constraints) -> path
    with path := <to-path(|variable-counter, kValue)> (srcVertex, dstVertex, edge, constraints, quantifier)

  pathPattern-to-connections(|variable-counter, kValue):
    PathPattern(Vertex(n1), edgeVertices@[EdgeVertex(e, Vertex(n2))|_]) -> <conc> ([edge], edgesPathTail)
    with edge := <to-connection(|variable-counter, kValue)> (n1, e, n2)
       ; edgesPathTail := <get-connections-from-single-path(|variable-counter, kValue)> edgeVertices

  // base case: only one edgeVertex
  get-connections-from-single-path(|variable-counter, kValue):
    [EdgeVertex(_, _)] -> []
    
  // two or more edgeVertices
  get-connections-from-single-path(|variable-counter, kValue):
    [EdgeVertex(_, Vertex(n1)) | edgeVertices@[EdgeVertex(e, Vertex(n2))|_]]
    -> <conc> ([edge], edgesPathTail)
    with edge := <to-connection(|variable-counter, kValue)> (n1, e, n2)
       ; edgesPathTail := <get-connections-from-single-path(|variable-counter, kValue)> edgeVertices

  to-connection(|variable-counter, kValue):
    (n1, edgeOrPath, n2) -> connection
    where <?OutConn(_, quantifier) + ?InConn(_, quantifier) + ?UndirectedEdge(_, quantifier)> edgeOrPath
    with
      switch !edgeOrPath
        case ?OutConn(edgeOrPath', _):
          src := n1;
          dst := n2;
          dir := Outgoing()
        case ?InConn(edgeOrPath', _):
          src := n2;
          dst := n1;
          dir := Incoming()
        case ?UndirectedEdge(edgeOrPath', _):
          src := n1;
          dst := n2;
          dir := Undirected()
        otherwise: fail
      end;
      switch !edgeOrPath'
        case ?ElemContents(Some(e'), _, _, _):
          constraints := <get-inlined-constraints> edgeOrPath'
        ; if <has-at-most-one-binding> quantifier
          then connection := <origin-track-forced(!NormalizedEdge(src, e', dst, dir, quantifier, Constraints(constraints)))> edgeOrPath
          else srcVertex := <unique-name(|variable-counter, edgeOrPath)>
             ; dstVertex := <unique-name(|variable-counter, edgeOrPath)>
             ; edge := <origin-track-forced(!NormalizedEdge(srcVertex, e', dstVertex, dir, None(), Constraints([])))> edgeOrPath
             ; connection := <to-path(|variable-counter, kValue)> (n1, n2, edge, Constraints(constraints), quantifier)
          end
        case ?Some(Path(Some(pathName), pathPatternName, quantifier')):
          connection := Path(src, dst, pathPatternName, quantifier', pathName, dir, Reaches(), -1)
        otherwise: fail
      end

  to-connection(|variable-counter, kValue):
    (n1, t@ParenthesizedPath(v1, edge, v2, whereClause, quantifier), n2) -> path
    with if <has-at-most-one-binding> quantifier
         then srcVertex := <?Some(Vertex(<id>)) <+ ?None(); !n1> v1
            ; dstVertex := <?Some(Vertex(<id>)) <+ ?None(); !n2> v2
         else srcVertex := <?Some(Vertex(<id>)) <+ ?None(); unique-name(|variable-counter, edge)> v1
            ; dstVertex := <?Some(Vertex(<id>)) <+ ?None(); unique-name(|variable-counter, edge)> v2
         end
       ; edge' := <to-connection(|variable-counter, kValue)> (srcVertex, edge, dstVertex)
       ; inlinedEdgeConstraints := <?NormalizedEdge(_, _, _, _, _, Constraints(<id>))> edge'
       ; inlinedSrcVertexConstraints := <?Some(Vertex(<id>)); get-inlined-constraints <+ ![]> v1
       ; inlinedDstVertexConstraints := <?Some(Vertex(<id>)); get-inlined-constraints <+ ![]> v2
       ; constraints := <?None(); ![] <+ ?Some(WhereClause(constraint)); ![constraint]> whereClause
       ; constraints' := Constraints(<conc> (inlinedSrcVertexConstraints, inlinedEdgeConstraints, inlinedDstVertexConstraints, constraints))
       ; path := <to-path(|variable-counter, kValue)> (n1, n2, edge', constraints', quantifier)

  to-path(|variable-counter, kValue):
    (srcVertex, dstVertex, edge@NormalizedEdge(src, _, dst, direction, _, _), constraints, quantifier) -> path
    with name := <unique-name(|variable-counter, edge)>
       ; if <?Incoming()> direction
         then vertices := Vertices([Vertex(dst), Vertex(src)])
         else vertices := Vertices([Vertex(src), Vertex(dst)])
         end
       ; edges := Edges([edge])
       ; path-variable-name := <unique-name(|variable-counter, edge)> // for now, all paths are anonymous/generated
       ; commonPathExpression := CommonPathExpression(name, vertices, edges, constraints)
       ; path := <origin-track-forced(!Path(srcVertex, dstVertex, commonPathExpression, quantifier, path-variable-name, Outgoing(), Shortest(), kValue))> edge

rules

  norm-has-prop = ?Legacy10Has(varRef, [prop]); !Legacy10Has(varRef, prop) <+
                  ?Legacy10Has(varRef, <id>); map(!Legacy10Has(varRef, <id>)); create-conjunct

  create-conjunct = reverse; !(<Tl>, <Hd>); foldl(create-OR)
  create-OR = ?(exp1, exp2); !And(exp1, exp2)

rules

  norm-hop-distance = ?ZeroOrMore(); !BetweenNAndM("0", "-1")
  norm-hop-distance = ?OneOrMore(); !BetweenNAndM("1", "-1")
  norm-hop-distance = ?Optional(); !BetweenNAndM("0", "1")
  norm-hop-distance = ?ExactlyN(n); !BetweenNAndM(n, n)
  norm-hop-distance = ?NOrMore(n); !BetweenNAndM(n, "-1")
  norm-hop-distance = ?BetweenZeroAndM(m); !BetweenNAndM("0", m)

rules

  // pgql 1.2
  norm-query(|error-messages, variable-counter):
    Query(commonPathExpressions, selectOrUpdateClause, FromClause(GraphMatch(optionalGraphName, graphPattern)), whereClause, groupByClause, havingClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.2", variable-counter)> (commonPathExpressions, selectOrUpdateClause, optionalGraphName, graphPattern', groupByClause, havingClause, orderByClause, limitOffsets)
    with <?GraphPattern(vertices, connections, Constraints(inlined-constraints))> graphPattern
       ; non-inlined-constraints := <?Some(WhereClause(<id>)); ![<id>] + ?None(); ![]> whereClause
       ; constraints := Constraints(<conc> (inlined-constraints,  non-inlined-constraints))
       ; graphPattern' := GraphPattern(vertices, connections, constraints)

  // pgql 1.1
  norm-query(|error-messages, variable-counter):
    Pgql11Query(commonPathExpressions, selectOrUpdateClause, fromClause, graphPattern, whereClause, groupByClause, havingClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.1", variable-counter)> (commonPathExpressions, selectOrUpdateClause, optionalGraphName, graphPattern', groupByClause, havingClause, orderByClause, limitOffsets)
    with optionalGraphName := <?None() + ?Some(Pgql11FromClause(graphName)); !Some(GraphName(graphName))> fromClause
       ; <?GraphPattern(vertices, connections, Constraints(inlined-constraints))> graphPattern
       ; non-inlined-constraints := <?Some(WhereClause(<id>)); ![<id>] + ?None(); ![]> whereClause
       ; constraints := Constraints(<conc> (inlined-constraints,  non-inlined-constraints))
       ; graphPattern' := GraphPattern(vertices, connections, constraints)

  // pgql 1.0
  norm-query(|error-messages, variable-counter):
    q@Pgql10Query(commonPathExpressions, selectClause, fromClause, graphPattern, groupByClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.0", variable-counter)> (commonPathExpressions, selectClause, optionalGraphName, graphPattern, groupByClause, havingClause, orderByClause, limitOffsets)
      with optionalGraphName := <?None() + ?Some(Pgql11FromClause(graphName)); !Some(GraphName(graphName))> fromClause
         ; havingClause := None()

  norm-query(|error-messages, version, variable-counter):
    (commonPathExpressions, selectOrUpdateClause, optionalGraphName, graphPattern, groupByClause, havingClause, orderByClause, limitOffsets) ->
        NormalizedQuery(commonPathExpressions', selectOrUpdateClause', optionalGraphName, graphPattern, groupByClause', havingClause, orderByElems, limitOffsets', error-messages, version)
    with
      commonPathExpressions' := <map(norm-common-path-expression(|variable-counter)); !CommonPathExpressions(<id>)> commonPathExpressions;

      expAsGroupVars := <?Some(GroupByClause(<id>)) <+ ![]> groupByClause;
      expAsGroupVars' := <map(norm-ExpAsVar(|version))> expAsGroupVars;
      groupByClause' := <?Some(_); !Some(GroupByClause(expAsGroupVars')) <+ !None()> groupByClause;

      selectOrUpdateClause' := <is-dml-operation + ?SelectClause(_, _); (norm-ExpAsVars(|expAsGroupVars', version) <+ norm-select-star(|graphPattern, expAsGroupVars', version))> selectOrUpdateClause;

      expAsSelectVars := <is-dml-operation; ![] + ?SelectClause(_, ExpAsVars(<id>))> selectOrUpdateClause';
      allExpAsVars := <conc> (expAsGroupVars', <try(?Star(); ![])> expAsSelectVars);
      orderByElems := <try(norm-orderBy(|allExpAsVars, version))> orderByClause;

      limitOffsets' := <norm-limitOffsets> limitOffsets

  norm-ExpAsVars(|expAsGroupVars', pgqlVersion):
    SelectClause(distinct, t@ExpAsVars(expAsVars)) -> SelectClause(distinct, <origin-track-forced(!ExpAsVars(expAsVars'))> t)
    with expAsVars' := <map(norm-ExpAsVar(|pgqlVersion))> expAsVars

  norm-ExpAsVar(|pgqlVersion) = ?ExpAsVar(exp, Some(VarAssign(VarDef(v)))); !ExpAsVar(exp, v, NonAnonymous())
  norm-ExpAsVar(|pgqlVersion) = ?ExpAsVar(exp, None()); !ExpAsVar(exp, <?VarRef(<id>) <+ propRef-to-columnName(|pgqlVersion) <+ origin-track-forced(origin-text)> exp, Anonymous())
  norm-ExpAsVar(|pgqlVersion) = ?ExpAsVar(_, v, _); where (<origin-offset> v)
  propRef-to-columnName(|pgqlVersion) = ?PropRef(_, Identifier(<id>)); where ( not ( <?"v1.0" + ?"v1.1"> pgqlVersion )) // only PGQL v1.2+ uses property names as column names 

  norm-select-star(|graphPattern, group-exps, pgqlVersion):
    SelectClause(distinct, star@Star()) -> SelectClause(star, <origin-track-forced(!ExpAsVars(expAsSelectVars))> star)
    with if [] := group-exps
         then vars := <collect(?Vertex(<id>) + ?NormalizedEdge(_, <id>, _, _, _, _) + ?Subquery(_)); filter(is-string; not(is-substring(GENERATED)))> graphPattern;
              expAsSelectVars := <map(generate-ExpAsVar(|star); norm-ExpAsVar(|pgqlVersion))> vars
         else expAsSelectVars := star
         end

  generate-ExpAsVar(|star):
    v -> expAsVar
    with v' := <origin-track-forced(!(v, ""); conc-strings /* generate a new string to make it loose origin */)> star
       ; varRef := <origin-track-forced(!VarRef(v'))> star
       ; expAsVar := <origin-track-forced(!ExpAsVar(varRef, v', Anonymous()))> star

  norm-orderBy(|allExpAsVars, version):
    Some(OrderByClause(elems)) -> Some(OrderByClause(elems'))
    with
      elems' := <map(norm-orderBy-ordering(|version))> elems

  norm-orderBy-ordering(|version) =
    ((?Desc(<id>) + ?Legacy10Desc(<id>)); !OrderByElem(<id>, Desc(), version)) <+
    ((try(?Asc(<id>) + ?Legacy10Asc(<id>))); !OrderByElem(<id>, Asc(), version))

  norm-limitOffsets = ?None(); !LimitOffsetClauses(None(), None())
  norm-limitOffsets = ?Some(LimitOffsetClauses(limitClause, offsetClause)); !LimitOffsetClauses(Some(limitClause), offsetClause)
  norm-limitOffsets = ?Some(OffsetLimitClauses(offsetClause, limitClause)); !LimitOffsetClauses(limitClause, Some(offsetClause))

  is-dml-operation = ?InsertClause(_, _, _) + ?UpdateClause(_)