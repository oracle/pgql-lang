module normalize

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-
  normalize-ddl

rules

  // CREATE PROPERTY GRAPH
  normalize-before(|variable-counter):
    ast -> <normalize-CreatePropertyGraph> ast
    where <is-CreatePropertyGraph> ast

  // DROP PROPERTY GRAPH
  normalize-before(|variable-counter):
    ast -> <normalize-DropPropertyGraph> ast
    where <is-DropPropertyGraph> ast

  // SELECT, INSERT, UPDATE or DELETE
  normalize-before(|variable-counter):
    astPlusMetadata -> AstPlusMetadata(result, metadata)
    where <not(is-ddl-statement)> astPlusMetadata
    with
      ast := <try(?AstPlusMetadata(<id>, _))> astPlusMetadata; // AST does not always come with metadata
      metadata := <?AstPlusMetadata(_, <id>) <+ ![]> astPlusMetadata;
      bindVariable-counter := <new-counter>;
      error-messages := <
        (  is-pgql10; collect(get-pgql10-limitation)
        <+ is-pgql11; (collect(get-pgql11-limitation); not(?[]) <+ collect(get-pgql11-deprecation))
        <+ is-pgql13; collect(get-pgql13-deprecation + get-pgql13-errors); not(?[]) <+ get-all-GraphTable-restrictions
        )
        ; not(?[]) <+ !( <quantifier-without-path-finding-goal>,
                         <get-all-nested-regular-expressions>,
                         <get-errors-for-inconsistent-graph-names>
                       ); conc> ast;
      result := <
        alltd(norm-BindVariable(|bindVariable-counter)); // give numbers to bind variables; this should happen before any other query transformation so that we maintain the order of bind variables as they appear in the original query
        alltd(norm-pgql10);
        alltd(
          norm-UMin +
          norm-DateTimeField +
          norm-source-destination-predicate
        );
        bottomup(try(norm-labeled-predicate));
        innermost(
          norm-NEQ +
          norm-singleVertex +
          norm-parenthesized-match-single-path +
          norm-isNull +
          norm-case
        );
      	alltd(norm-edgeContents);
        ( (is-pgql10 + is-pgql11); alltd((?PropRef(_, _) <+ varRef-to-legacy-string-literal) + norm-legacy-string-literal); alltd(norm-legacy-identifier) +
          is-pgql13; alltd(norm-string-literal + norm-identifier) +
          ?Start-Plhdr() // empty query string
        );
        alltd(norm-timezone(|metadata));
        alltd(norm-datetime-literal);
        alltd(norm-hop-distance);
        alltd(name-unnamed-elems(|variable-counter));
        alltd(norm-inlined-references);
        bottomup(try(
           norm-matchElems(|variable-counter)
        ));
        bottomup(try(origin-track-forced(norm-query(|error-messages, variable-counter, <get-counter> bindVariable-counter))));
        alltd(?ElemContents(Some(<id>), _, _, _));
        try(copy-graph-name-to-queries-without-one)
      > ast

rules

  is-pgql10 = ?Pgql10Query(_, _, _, _, _, _, _)
  is-pgql11 = ?Pgql11Query(_, _, _, _, _, _, _, _)
  is-pgql13 = ?Query(_, _, _, _, _, _, _)

  get-pgql11-deprecation = (?OutConn(None(), _) + ?InConn(None(), _) + ?UndirectedEdge(None(), _)); to-error-message(|"Use [-] instead of [--]")

  get-pgql11-deprecation = (?Legacy10Label(_) + get-pgql11-deprecation-helper(|"LABEL", 0, False())); to-error-message(|"Use [label(x)] instead of [x.label()]")
  get-pgql11-deprecation = (?Legacy10Labels(_) + get-pgql11-deprecation-helper(|"LABELS", 0, False())); to-error-message(|"Use [labels(x)] instead of [x.labels()]")
  get-pgql11-deprecation = (?Legacy10HasLabel(_, _) + get-pgql11-deprecation-helper(|"HASLABEL", 1, False())); to-error-message(|"Use [has_label(x, 'lbl')] instead of [x.hasLabel('lbl')]")
  get-pgql11-deprecation = (?Legacy10Id(_) + get-pgql11-deprecation-helper(|"ID", 0, False())); to-error-message(|"Use [id(x)] instead of [x.id()]")
  get-pgql11-deprecation = (?Legacy10Has(_, _) + get-pgql11-deprecation-helper(|"HAS", -1, True())); to-error-message(|"Use [x.prop IS NOT NULL] instead of [x.has(prop)]")
  get-pgql11-deprecation = (?Legacy10InDegree(_) + get-pgql11-deprecation-helper(|"INDEGREE", 0, False())); to-error-message(|"Use [in_degree(x)] instead of [x.inDegree()]")
  get-pgql11-deprecation = (?Legacy10OutDegree(_) + get-pgql11-deprecation-helper(|"OUTDEGREE", 0, False())); to-error-message(|"Use [out_degree(x)] instead of [x.outDegree()]")

  get-pgql11-deprecation-helper(|functionNameToMatch, numArgsToMatch, anyNumberOfArgs):
    t@FunctionCall(Some(PackageName(None(), x)), RegularIdentifier(functionName), args) -> t
    where <eq> (<upper-case> functionName, functionNameToMatch)
        ; if <?False()> anyNumberOfArgs
          then <eq> (<length> args, numArgsToMatch)
          end

  get-pgql11-deprecation = ?Legacy10Asc(x); to-error-message(|$<Use [<<origin-text> x> ASC] instead of [ASC(<<origin-text> x>)]>)
  get-pgql11-deprecation = ?Legacy10Desc(x); to-error-message(|$<Use [<<origin-text> x> DESC] instead of [DESC(<<origin-text> x>)]>)
  get-pgql11-deprecation = ?Legacy10Identifier(_); to-error-message(|"Use double quotes to delimit labels")
  get-pgql11-deprecation = ?Ids(_); to-error-message(|"Use [id(x) = xyz] instead of [@xyz]")
  get-pgql11-deprecation = ?InlinedConstraint(_); to-error-message(|"Constraints should be specified in the WHERE clause instead of the WITH")

  get-pgql11-deprecation = ?LimitOffsetClauses(FetchFirstClause(_, _, _), Some(offsetClause)); !offsetClause; to-error-message(|"OFFSET clause should come before FETCH FIRST clause")

  get-pgql13-deprecation = get-pgql11-deprecation // sharing all the deprecations with 1.1

  get-pgql13-errors      = ?GraphMatch(None(), _, _); to-error-message(|"Missing MATCH keyword at start of pattern")

  get-pgql13-errors:
    ParenthesizedGraphMatch(_, _, optionalGraphMatchParts) -> <error-for-rows-clause-when-multiple-path-patterns> rowsPerMatch
    where rowsPerMatch := <get-RowsPerMatch; ?Some(<id>)> optionalGraphMatchParts
        ; <is-not-one-row-per-match> rowsPerMatch

  error-for-rows-clause-when-multiple-path-patterns = to-error-message(|"ONE ROW PER VERTEX or STEP is only permitted if the MATCH clause contains a single path pattern")

  // MATCH (n) ONE ROW PER VERTEX (v)
  get-pgql13-errors:
    graphMatch -> <to-error-message(|"ONE ROW PER VERTEX or STEP is only supported in combination with an edge pattern and quantifier")> rowsPerMatch
    where <?GraphMatch(_, SingleVertex(_), Some(OptionalGraphMatchParts1(rowsPerMatch, _))) +
           ?GraphMatch(_, PathPattern2(_, SingleVertex(_)), Some(OptionalGraphMatchParts1(rowsPerMatch, _)))> graphMatch
        ; <is-not-one-row-per-match> rowsPerMatch

  is-not-one-row-per-match = ?OneRowPerVertex(_) + ?OneRowPerEdge(_) + ?OneRowPerStep(_, _, _)

  get-pgql10-limitation = ( ?Pgql11FromClause(_)
                          + ?Subquery(_)
                          + ?Pgql11AsignSymbol()
                          + ?ExtractExp(_, _)
                          + ?ARRAY-AGG(_, _)
                          + ?PathPattern2(Some(_), _)
                          )
                        ; to-error-message(|"Use [SELECT .. FROM MATCH .. WHERE ..]")

  get-pgql11-limitation = ?VarRef(DelimitedIdentifier(<id>)); to-error-message(|"Double quoted variable references are only available in PGQL 1.3 and up")
                        + ?ModifyClause(_); to-error-message(|"INSERT, UPDATE and DELETE are only supported in PGQL 1.3 and up (use FROM MATCH ...)")

  get-all-GraphTable-restrictions:
    ast -> restrictions
    with if <oncetd(?GraphTable(_, _, _))> ast
         then restrictions := <collect-all(get-GraphTable-restriction, conc)> ast
         else restrictions := []
         end

  get-GraphTable-restriction = ?Labels(c@Colon(), _); !c; to-error-message(|"GRAPH_TABLE restriction: use IS instead of :")

  get-GraphTable-restriction = (?GraphMatch(_, _, _) +  ?ParenthesizedGraphMatch(_, _, _)); to-error-message(|<wrap-match-in-graph-table-error>)
  get-GraphTable-restriction = (?GraphMatch(_, _, _) +  ?ParenthesizedGraphMatch(_, _, _)); to-error-message(|<wrap-match-in-graph-table-error>)
  wrap-match-in-graph-table-error = !"GRAPH_TABLE restriction: wrap top-level MATCH in GRAPH_TABLE"

  get-GraphTable-restriction = ?LimitClause(x); to-error-message(|$<GRAPH_TABLE restriction: use FETCH FIRST <<origin-text> x> ROWS ONLY instead of LIMIT <<origin-text> x>>)

  get-GraphTable-restriction = ?AnyShortestPathSearch2(_); to-error-message(|"GRAPH_TABLE restriction: use ANY SHORTEST or ALL SHORTEST instead of SHORTEST")

  get-GraphTable-restriction = ?AnyCheapestPathSearch2(_); to-error-message(|"GRAPH_TABLE restriction: use ANY CHEAPEST instead of CHEAPEST")

  get-GraphTable-restriction = ?CountedShortestPathSearch2(NumberOfPaths(k)); to-error-message(|$<GRAPH_TABLE restriction: use SHORTEST <k> instead of TOP <k> SHORTEST>)

  get-GraphTable-restriction:
    e@FunctionCall(None(), functionName, [VarRef(x), y]) -> error
    where <norm-identifier; ?Identifier(<id>, _); lower-case; ?"has_label"> functionName
    with if <?String(s)> y
         then error := <to-error-message(|$<GRAPH_TABLE restriction: use <<origin-text> x> IS LABELED "<<un-single-quote> s>">)> e
         else error := <to-error-message(|$<GRAPH_TABLE restriction: HAS_LABEL function is not supported; try using the IS LABELED predicate>)> e
         end

  get-GraphTable-restriction:
    e@FunctionCall(None(), functionName, [edge@VarRef(_), vertex@VarRef(_)]) -> error-message
    with functionName' := <norm-identifier> functionName
       ; if <?Identifier("IS_SOURCE_OF", _)> functionName'
          then error-message := <to-error-message(|$<GRAPH_TABLE restriction: use <<origin-text> vertex> IS SOURCE OF <<origin-text> edge>>)> e
          else if <?Identifier("IS_DESTINATION_OF", _)> functionName'
               then error-message := <to-error-message(|$<GRAPH_TABLE restriction: use <<origin-text> vertex> IS DESTINATION OF <<origin-text> edge>>)> e
               end
          end

  get-GraphTable-restriction = ?Path(_, _, _); to-error-message(|"GRAPH_TABLE restriction: -/../-> not supported")

  get-GraphTable-restriction:
    e@FunctionCall(None(), functionName, [_]) -> <to-error-message(|"GRAPH_TABLE restriction: MATCHNUM with argument not supported, use MATCHNUM without argument instead")> e
    where <norm-identifier; ?Identifier("MATCHNUM", _)> functionName

  get-GraphTable-restriction = ?KeepClause(_); to-error-message(|"KEEP clause not yet supported")

  get-GraphTable-restriction:
    GraphTable(_, GraphPattern(PathPatternList(pathPatterns), _, _), GraphTableShape(Some(rowsClause), _))
      -> <error-for-rows-clause-when-multiple-path-patterns> rowsClause
    where <length; not(?1)> pathPatterns
        ; <?OneRowPerVertex(_) + ?OneRowPerStep(_, _, _)> rowsClause

  quantifier-without-path-finding-goal =
    collect(quantified-path-pattern <+ is-quantifier)
  ; remove-all(quantified-path-pattern)
  ; map(to-error-message(|"Quantifier needs to be enclosed by ANY, ALL, SHORTEST or CHEAPEST"))

  get-all-nested-regular-expressions = collect(get-nested-regular-expression)

  get-nested-regular-expression:
    t@PathPattern2(_, _) -> error
    where pathPatterns := <collect-all(?PathPattern2(Some(_), _) + // e.g. ANY SHORTEST ...
                                       ?Path(_, _, _))> t // e.g. -/../->*
        ; [PathPattern2(pathPatternPrefix1, _)|[nestedPath|_]] := pathPatterns
    with if <?PathPattern2(pathPatternPrefix2, _)> nestedPath
         then error := <to-error-message(|"Nested path-finding goals not allowed")> pathPatternPrefix2 // e.g. ANY ( ANY .. )
         else error := <to-error-message(|$<Reachability not allowed here since pattern has path-finding goal <<origin-text; upper-case; trim-whitespace> pathPatternPrefix1>>)> nestedPath // e.g. ANY .. -/:knows*/->
         end

  get-errors-for-inconsistent-graph-names:
    ast -> <conc> (errors-for-multiple-graph-name, errors-for-missing-on-clauses)
    with errors-for-multiple-graph-name := <get-errors-for-multiple-graph-names> ast
       ; if <is-pgql10 + is-pgql11> ast
         then errors-for-missing-on-clauses := [] // before PGQL 1.3 we didn't have these error yet
         else errors-for-missing-on-clauses := <get-errors-for-missing-on-clauses> ast
         end

  get-errors-for-multiple-graph-names:
    ast -> errors
    with inputGraphNames := <collect-all(get-graph-name; alltd(norm-identifier); to-name-without-case-sensitive-info); make-set> ast
       ; numInputGraphNames := <length> inputGraphNames
       ; if <gt> (numInputGraphNames, 1)
         then errors := <map(to-error-message(|"Querying multiple graphs is not supported"))> inputGraphNames
         else errors := []
         end

  get-graph-name = ?GraphMatch(_, _, Some(OptionalGraphMatchParts1(_, Some(OnClause(<id>)))))
                 + ?ParenthesizedGraphMatch(_, _, Some(OptionalGraphMatchParts1(_, Some(OnClause(<id>)))))
                 + ?GraphMatch(_, _, Some(OptionalGraphMatchParts2(OnClause(<id>), _)))
                 + ?ParenthesizedGraphMatch(_, _, Some(OptionalGraphMatchParts2(OnClause(<id>), _)))
                 + ?GraphTable(Some(<id>), _, _)
                 + ?GraphName(<id>) // for lateral subqueries that are already normalized at this point

  get-RowsPerMatch = ?None()
                   + origin-track-forced(?Some(OptionalGraphMatchParts1(<id>, _)); (?None() <+ !Some(<id>)))
                   + origin-track-forced(?Some(OptionalGraphMatchParts2(_, <id>)))

  get-errors-for-missing-on-clauses:
    ast -> errors
    with if <oncetd(?OnClause(_) + ?GraphTable(_, _, _))> ast
         then clausesWithMissingGraphName := <collect(?GraphMatch(_, _, Some(OptionalGraphMatchParts1(_, None())))
						                            + ?ParenthesizedGraphMatch(_, _, Some(OptionalGraphMatchParts1(_, None())))
						                            + ?GraphMatch(_, _, None())
						                            + ?ParenthesizedGraphMatch(_, _, None())
						                            + ?GraphTable(None(), _, _))> ast
            ; errors := <map(?GraphTable(_, _, _); to-error-message(|"GRAPH_TABLE restriction: graph name required") <+ to-error-message(|"Missing graph name"))> clausesWithMissingGraphName
         else errors := []
         end

  quantified-path-pattern = ?PathPattern2(_, _)
                          + ?OutConn(Path(_, _, _), _)
                          + ?InConn(Path(_, _, _), _)

  norm-pgql10 = ?Legacy10Label(x); <to-function(|"label")> [x]
  norm-pgql10 = ?Legacy10Labels(x); <to-function(|"labels")> [x]
  norm-pgql10 = ?Legacy10HasLabel(x, lbl); <to-function(|"has_label")> [x, lbl]
  norm-pgql10 = ?Legacy10Id(x); <to-function(|"id")> [x]
  norm-pgql10 = ?Legacy10InDegree(x); <to-function(|"in_degree")> [x]
  norm-pgql10 = ?Legacy10OutDegree(x); <to-function(|"out_degree")> [x]

  // e.g. x.id() (PGQL 1.0) => id(x) (PGQL 1.1+)
  norm-pgql10 = norm-pgql10-function-helper(|"LABEL", 0, "label")
  norm-pgql10 = norm-pgql10-function-helper(|"LABELS", 0, "labels")
  norm-pgql10 = norm-pgql10-function-helper(|"HASLABEL", 1, "has_label")
  norm-pgql10 = norm-pgql10-function-helper(|"ID", 0, "id")
  norm-pgql10 = norm-pgql10-function-helper(|"INDEGREE", 0, "in_degree")
  norm-pgql10 = norm-pgql10-function-helper(|"OUTDEGREE", 0, "out_degree")

  norm-pgql10-function-helper(|pgql10FunctionName, numArgsToMatch, pgql11FunctionName):
    t@FunctionCall(Some(PackageName(None(), x)), RegularIdentifier(functionName), args) -> result
    where <eq> (<upper-case> functionName, pgql10FunctionName)
        ; <eq> (<length> args, numArgsToMatch)
        ; result := <origin-track-forced(![VarRef(x)|args]; to-function(|pgql11FunctionName))> t

  norm-pgql10 = ?Legacy10Has(varRef, <id>); map(![varRef, <id>]; to-function(|"has_prop")); to-conjunction
  norm-pgql10:
    t@FunctionCall(Some(PackageName(None(), x)), RegularIdentifier(functionName), propertyNames) -> result
    where <eq> ( <upper-case> functionName, "HAS" )
    with replacement-expression := <map(to-has-prop-function(|x, t)); to-conjunction> propertyNames
       ; result := <origin-track-forced(!replacement-expression)> t

  to-has-prop-function(|var, originTerm):
    propertyName -> result
    with args := [VarRef(var), propertyName]
       ; result := <origin-track-forced(!args; to-function(|"has_prop"))> originTerm

  // In PGQL 1.1 and PGQL 1.2, subqueries would inherit the graph name from the outer query.
  // This is no longer the case in PGQL 1.3+, where graph names in subqueries need to be respecified.
  copy-graph-name-to-queries-without-one:
    ast@NormalizedQuery(_, _, _, _, _, _, _, _, _, _, "v1.1", _, _) -> ast'
    where <oncetd(?NormalizedQuery(_, _, Some(graphName), _, _, _, _, _, _, _, _, _, _))> ast
    with ast' := <innermost(copy-graph-name-to-query-without-one(|graphName))> ast

  copy-graph-name-to-query-without-one(|graphName):
    NormalizedQuery(a, b, None(), c, d, e, f, g, h, i, j, k, l) -> NormalizedQuery(a, b, Some(graphName), c, d, e, f, g, h, i, j, k, l)

  norm-BindVariable(|c) = ?BindVariable(); !BindVariable(<next-counter> c)

  norm-UMin = ?UMin(Integer(string)); !Integer(<conc-strings> ("-", string))
  norm-UMin = ?UMin(Decimal(string)); !Decimal(<conc-strings> ("-", string))

  norm-NEQ = ?Neq1(exp1, exp2); !Neq(exp1, exp2)
  norm-NEQ = ?Neq2(exp1, exp2); !Neq(exp1, exp2)

  norm-legacy-string-literal:
    String(s) -> String(s')
    with s' := <origin-track-forced(un-single-quote; unescape-legacy-string-literal)> s

  varRef-to-legacy-string-literal:
    VarRef(DelimitedIdentifier(s)) -> String(s')
    with s' := <origin-track-forced(un-double-quote; unescape-legacy-identifier)> s

  norm-legacy-identifier:
    RegularIdentifier(v) -> Identifier(v, v)

  norm-legacy-identifier:
    DelimitedIdentifier(v) -> Identifier(v', v')
    with v' := <origin-track-forced(un-double-quote; unescape-legacy-identifier)> v

  // (n:'lbl')
  norm-legacy-identifier:
    Legacy10Identifier(v) -> Legacy10Identifier(v')
    with v' := <origin-track-forced(un-single-quote; unescape-legacy-string-literal)> v

  external unescape-legacy-string-literal(|)
  external unescape-legacy-identifier(|)

  norm-datetime-literal = Date(un-single-quote)
                        + Time(un-single-quote)
                        + Timestamp(un-single-quote)

  norm-timezone(|metadata):
    Cast(exp, type) -> Cast(exp, type'')
    with type' := <origin-track-forced(upper-case
                  /* In standard SQL the time zone is denoted by "TIME ZONE" while in java.sql.* it's denoted by "TIMEZONE".
                     Clearly people have been confusing it. Therefore, we support both notations in PGQL by normalizing one
                     into the other. Users can then use either. However, please stick to TIME ZONE (with space) in
                     documentation to follow the standard. */
                  ; string-replace(|"TIME ZONE", "TIMEZONE"))> type
        ; type'' := <try(origin-track-forced(!metadata; fetch-elem(?DataTypeSynonyms(<id>)); fetch-elem(?DataTypeSynonym(type', <id>))))> type'

  norm-isNull = ?IsNotNull(exp); origin-track-forced(!IsNull(exp)); !Not(<id>)

  norm-DateTimeField = DateTimeField(origin-track-forced(upper-case))

  norm-case:
    t@SimpleCase(caseOperand, whenClauses, elseClause) -> SimpleCase(caseOperand, whenClauses, elseClause, ifElseRepresentation)
    with ifElseRepresentation := <to-if-else(|t)> (caseOperand, whenClauses, elseClause)

  to-if-else(|origin-term):
    (caseOperand, whenClauses, elseClause) -> ifElse
    with [WhenClause(whenExp, thenExp)|xs] := whenClauses
       ; exp1 := <origin-track-forced(!Eq(caseOperand, whenExp))> whenExp
       ; exp2 := thenExp
       ; if [] := xs
         then exp3 := <to-else> elseClause
         else exp3 := <to-if-else(|elseClause)> (caseOperand, xs, elseClause)
         end
       ; ifElse := <origin-track-forced(!IfElse(exp1, exp2, exp3))> origin-term

  norm-case:
    t@SearchedCase(whenClauses, elseClause) -> ifElse
    with ifElse := <to-if-else(|t)> (whenClauses, elseClause)
       ; <origin-text> t

  to-if-else(|origin-term):
    (whenClauses, elseClause) -> ifElse
    with [WhenClause(whenExp, thenExp)|xs] := whenClauses
       ; exp1 := whenExp
       ; exp2 := thenExp
       ; if [] := xs
         then exp3 := <to-else> elseClause
         else [WhenClause(_, thenExp2)|_] := xs
            ; exp3 := <to-if-else(|thenExp2)> (xs, elseClause)
         end
       ; ifElse := <origin-track-forced(!IfElse(exp1, exp2, exp3))> origin-term

  to-else = ?None(); !Null() <+ ?Some(ElseClause(<id>))

  norm-labeled-predicate:
    LabeledPredicate(varRef, notTerm, labelExpression) -> result
    with labelExpression' := <to-label-constraint(|varRef)> labelExpression
       ; if <?Some(_)> notTerm
         then result := Not(labelExpression')
         else result := labelExpression'
         end

  norm-labeled-predicate:
    FunctionCall(None(), functionName, args@[VarRef(_), String(_)]) -> FunctionCall(None(), Identifier("has_label", origin), args)
    where <norm-identifier; ?Identifier(<id>, origin); lower-case; ?"has_label"> functionName

  norm-source-destination-predicate:
    t@SourcePredicate(vertexRef, notTerm, _, edgeRef) -> <origin-track-forced(!result)> t
    with isSourceOfCall := FunctionCall(None(), RegularIdentifier("is_source_of"), [edgeRef, vertexRef])
       ; if <?Some(_)> notTerm
         then result := Not(isSourceOfCall)
         else result := isSourceOfCall
         end

  norm-source-destination-predicate:
    t@DestinationPredicate(vertexRef, notTerm, _, edgeRef) -> <origin-track-forced(!result)> t
    with isDestinationOfCall := FunctionCall(None(), RegularIdentifier("is_destination_of"), [edgeRef, vertexRef])
       ; if <?Some(_)> notTerm
         then result := Not(isDestinationOfCall)
         else result := isDestinationOfCall
         end

rules

  norm-singleVertex = ?SingleVertex(elemContents); !PathPattern2(None(), PathPattern(Vertex(elemContents), [])) // SELECT * WHERE ()

  // translate e.g. MATCH ( (n) -> (m) ) to MATCH (n) -> (m)
  norm-parenthesized-match-single-path:
    PathPattern2(pathPatternPrefix1, pathPattern@PathPattern2(pathPatternPrefix2, pathPatternContent)) -> pathPattern'
    with pathPatternPrefix' := <?Some(_) <+ !pathPatternPrefix2> pathPatternPrefix1 // take either prefix (if there are two then we'll generate an error below)
       ; pathPattern' := <origin-track-forced(!PathPattern2(pathPatternPrefix', pathPatternContent))> pathPattern

  get-pgql13-errors:
    PathPattern2(Some(pathPatternPrefix1), PathPattern2(Some(pathPatternPrefix2), _)) -> <to-error-message(|"Nested path pattern prefix not allowed")> pathPatternPrefix2

  norm-edgeContents = ?EdgeContents(<id>)

  name-unnamed-elems(|c) = (?CommonPathExpression(_, _, _, _, _) + ?GraphPattern(_) + ?MatchWhereClauses(_, _) + ?PathPattern(_, _)); alltd(name-unnamed-elem(|c))
  name-unnamed-elem(|c) = ?ElemContents(None(), type, id', constraints); ?origin; !ElemContents(Some(<unique-name(|c, origin)>), type, id', constraints)
  name-unnamed-elem(|c) = ?origin; (OutConn(?None(); name-unnamed-elem-helper(|c, origin), id) +
                           InConn(?None(); name-unnamed-elem-helper(|c, origin), id) +
                           UndirectedEdge(?None(); name-unnamed-elem-helper(|c, origin), id))
  name-unnamed-elem(|c) = ?OutEdge(quantifier); ?origin; !OutConn(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?InEdge(quantifier); ?origin; !InConn(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?UndirectedEdge(quantifier); ?origin; !UndirectedEdge(<name-unnamed-elem-helper(|c, origin)>, quantifier) +
                          ?Path(None(), pathPatternRef, kleeneStar); ?origin; !Path(Some(<unique-name(|c, origin)>), pathPatternRef, kleeneStar)
  name-unnamed-elem-helper(|c, origin) = !ElemContents(Some(<unique-name(|c, origin)>), None(), None(), None())

  norm-inlined-references = ?ElemContents(Some((varName)), _, _, _); alltd(norm-inlined-reference(|varName))
  norm-inlined-reference(|varName) =
    ?Obj(dot); !VarRef(varName) + (?Obj(VarRef(v), dot) + ?PropRef(VarRef(v), _));
    if <eq> (v, varName)
    then !ReferenceInInlinedConstraint(v)
    else !CrossReferenceInInlinedConstraint(v)
    end +
    (?SelfPropRef(propName) + ?SelfPropRef(dot, propName)); !PropRef(VarRef(varName), Identifier(propName, propName))

rules

  // PGQL 1.3
  norm-matchElems(|variable-counter):
    FromWhereClauses(tableExpressions, whereClause) -> TableExpressionsAndGraphName(tableExpressions', graphName, whereClause)
    with graphName := <collect-one(get-graph-name; !Some(GraphName(<id>))) <+ !None()> tableExpressions // simply take the first graph name we see; we don't support multiple graph right now
       ; tableExpressions' := <normalize-table-expressions(|variable-counter, [])> tableExpressions

  // normalizes the MATCH expressions and merges consequetive MATCH expressions together into a single GraphPattern
  normalize-table-expressions(|variable-counter, graphMatches):
    tableExpressions -> tableExpressions'
    with if <?[]> tableExpressions
         then if <?[]> graphMatches
              then tableExpressions' := tableExpressions
              else pathPatternsWithRowsPerMatch := <get-pathPatternsAndRowsPerMatch-and-normalize(|variable-counter)> graphMatches
                 ; tableExpressions' := [pathPatternsWithRowsPerMatch]
              end
         else <?[x|xs]> tableExpressions
            ; if <?GraphMatch(_, _, _) + ?ParenthesizedGraphMatch(_, _, _)> x
              then graphMatches' := <conc> (graphMatches, [x])
                 ; tableExpressions' := <normalize-table-expressions(|variable-counter, graphMatches')> xs
              else x' := <normalize-table-expression(|variable-counter)> x
                 ; if <?[]> graphMatches
                   then tableExpressions' := [x'|<normalize-table-expressions(|variable-counter, graphMatches)> xs]
                   else pathPatternsWithRowsPerMatch := <get-pathPatternsAndRowsPerMatch-and-normalize(|variable-counter)> graphMatches
                      ; tableExpressions' := [pathPatternsWithRowsPerMatch| [x'|<normalize-table-expressions(|variable-counter, [])> xs] ]
                   end
              end
         end

  normalize-table-expression(|variable-counter) = ?DerivedTable(_, _, _)

  get-pathPatternsAndRowsPerMatch-and-normalize(|variable-counter) = map(get-pathPatternsAndRowsPerMatch); concat; norm-matchElems-common(|variable-counter)

  get-pathPatternsAndRowsPerMatch = ?GraphMatch(_, pathPattern, optionalGraphMatchParts); ![PathPatternAndRowsPerMatch(pathPattern, <get-RowsPerMatch> optionalGraphMatchParts)]
                                  + ?ParenthesizedGraphMatch(pathPattern1, otherPathPatterns, optionalGraphMatchParts); !([pathPattern1], otherPathPatterns); conc; map(!PathPatternAndRowsPerMatch(<id>, <get-RowsPerMatch> optionalGraphMatchParts))

  // PGQL 1.1 and 1.2
  norm-matchElems(|variable-counter):
    MatchWhereClauses(elems, whereClause) -> GraphPattern(vertices, connections, constraints)
    with <?GraphPattern(vertices, connections, Constraints(inlined-constraints))> := <norm-matchElems-common(|variable-counter)> elems
       ; non-inlined-constraints := <?Some(WhereClause(<id>)); ![<id>] + ?None(); ![]> whereClause
       ; constraints := Constraints(<conc> (inlined-constraints,  non-inlined-constraints))

  // PGQL 1.0
  norm-matchElems(|variable-counter):
    GraphPattern(elems) -> graphPattern
    with graphPattern := <norm-matchElems-common(|variable-counter)> elems

  norm-matchElems-common(|variable-counter):
    matchElems -> GraphPattern(vertices, connections, constraints)
    with pathPatterns := <remove-all(?Constraint(_))> matchElems // relevant to PGQL 1.0 only
       ; vertices := <collect-outside-repeated-path(?Vertex(ElemContents(Some(<id>), _, _, _)); !Vertex(<id>)); remove-duplicate-vertices; !Vertices(<id>)> pathPatterns
       ; connections := <get-connections-from-paths(|variable-counter, None())> pathPatterns

       ; non-inlined-constraints := <filter(?Constraint(<id>))> matchElems // PGQL 1.0 only
       ; inlined-constraints-for-vertices := <collect-outside-repeated-path(?Vertex(<id>))
                                           ; map(get-inlined-constraints); concat> pathPatterns
       ; inlined-constraints-for-edges := <collect-outside-repeated-path(?OutConn(<id>, None())
                                                                       + ?InConn(<id>, None())
                                                                       + ?UndirectedEdge(<id>, None()))
                                        ; filter(get-inlined-constraints); concat> pathPatterns
       ; constraints := <conc; flatten-list; !Constraints(<id>)> (inlined-constraints-for-vertices, inlined-constraints-for-edges, non-inlined-constraints)

  collect-outside-repeated-path(s) = collect-but-preserve-order(ParenthesizedPath + s); remove-all(ParenthesizedPath)

  collect-but-preserve-order(s) = collect-om(s, reverse-then-union); reverse // to preserve order of vertices

  reverse-then-union:
    (x, y) -> <union> (y, x)

  // ignore origin text so that we don't end up with duplicate vertices because of case insensitivity
  // Vertex(Identifier("N","n")),Vertex(Identifier("N","N")) ==> Vertex(Identifier("N","n")))
  remove-duplicate-vertices:
    vertices -> vertices'
    where not ( <?[]> vertices )
    with init := <init> vertices
       ; last@Vertex(Identifier(n, _)) := <last> vertices
       ; if <fetch(?Vertex(Identifier(n, _)))> init
         then vertices' := <remove-duplicate-vertices> init
         else vertices' := <conc> (<remove-duplicate-vertices> init, [last])
         end

  remove-duplicate-vertices = ?[] // base case; empty list

  ParenthesizedPath = ?ParenthesizedPath(_, _, _, _)

  norm-common-path-expression(|variable-counter):
    CommonPathExpression(name, _, path, whereClause, costClause) -> CommonPathExpression(name, vertices, connections, constraints, costClause)
    with
      inlined-constraints-for-vertices := <collect-om(?Vertex(<id>)); map(get-inlined-constraints); concat> path;
      inlined-constraints-for-edges := <collect-om(?OutConn(<id>, _) + ?InConn(<id>, _) + ?UndirectedEdge(<id>, _)); filter(get-inlined-constraints); concat> path;
      non-inlined-constraints := <(?None(); ![]) <+ (?Some(WhereClause(<id>)); ![<id>])> whereClause;
      constraints := <concat; flatten-list; !Constraints(<id>)> [inlined-constraints-for-vertices, inlined-constraints-for-edges, non-inlined-constraints];
      vertices := <collect-om(?Vertex(_), conc); !Vertices(<id>)> path;
      connections := <get-connections-from-paths(|variable-counter, None()); !Edges(<id>)> [path]

  get-inlined-constraints:
    ElemContents(Some(var), label, id', otherConstraint) -> <concat> [labels, identifiers, otherConstraint']
    with varRef := VarRef(var)
       ; labels := <?Some(Labels(_, <id>)); to-label-constraint(|varRef); ![<id>] <+ ![]> label
       ; identifiers := <?Some(Ids(<id>)); to-id-constraint(|var); ![<id>] <+ ![]> id'
       ; otherConstraint' := <?Some(InlinedConstraint(<id>)) <+ ![]> otherConstraint

  to-label-constraint(|varRef):
    labels -> <to-hasLabel-expressions(|varRef)> labels
  to-hasLabel-expressions(|varRef) = bottomup(try(![varRef, <to-label>]; to-function(|"has_label") + origin-track-forced(normalize-label-disjunction)))
  to-label = ?Label(<id>) + ?Legacy10Identifier(<id>); origin-track-forced(!Identifier(<id>, <id>)) + ?BindVariable(_)
  to-id-constraint(|var) = bottomup(try(is-literal; origin-track-forced(!Eq(<to-function(|"id")> [VarRef(var)], <id>))))
  normalize-label-disjunction = ?LabelDisjunction(x, y); !Or(x, y)

  // base case: no paths
  get-connections-from-paths(|variable-counter, rowsPerMatch):
    [] -> []

  get-connections-from-paths(|variable-counter, _):
    [PathPatternAndRowsPerMatch(pathPattern, rowsPerMatch)|otherPaths] -> <get-connections-from-paths(|variable-counter, rowsPerMatch)> [pathPattern|otherPaths]

  // first path pattern has only one vertex => ignore it
  get-connections-from-paths(|variable-counter, rowsPerMatch):
    [PathPattern2(_, PathPattern(_, []))|otherPaths] -> <get-connections-from-paths(|variable-counter, rowsPerMatch)> otherPaths

  // first path pattern has more than one vertex
  get-connections-from-paths(|variable-counter, rowsPerMatch):
    [PathPattern2(pathPatternPrefix, pathPattern)|otherPaths] -> result
    where <not(?PathPattern(_, []))> pathPattern
    with if <contains-edge-pattern-with-quantifier + !rowsPerMatch; ?Some(<id>); is-not-one-row-per-match + !pathPatternPrefix; not(?None() + ?Some(AllPathSearch(_, _)))> pathPattern // path pattern has a quantifier or it has a search prefix other than ALL or it has a graph table rows clause other than ONE ROW PER MATCH
         then pathFindingGoal := <to-pathFindingGoal> pathPatternPrefix
            ; topKAnyAll := <to-topKAnyAll> pathPatternPrefix
            ; pathMode := <to-pathMode> pathPatternPrefix
            ; result := <get-connections-from-quantified-path-patterns(|variable-counter, rowsPerMatch)> (pathFindingGoal, topKAnyAll, pathMode, pathPattern, otherPaths)
         else topKAnyAll := None()
            ; pathFindingGoal := None()
            ; pathMode := Walk()
            ; edges := <pathPattern-to-connections(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> pathPattern
            ; edgesTailPaths := <get-connections-from-paths(|variable-counter, rowsPerMatch)> otherPaths
            ; result := <conc> (edges, edgesTailPaths)
         end

  contains-edge-pattern-with-quantifier = collect-om(?Path(_, _, _) <+ is-quantifier) // in case of (n) -[e:lbl]->* (m) -/:lbl*/-> (o) we are only intersted in the first star, so we test if there exist at least one edge pattern with quantifier by ignoring paths with quantifiers
                                        ; filter(is-quantifier); not(?[])

  to-pathFindingGoal = ?None(); !All() +
                       ( ?Some(PathModePrefix(_, _)) +
                         ?Some(AllPathSearch(_, _))
                       )
                     ; origin-track-forced(!All())

  to-pathFindingGoal = ?Some(AnyPathSearch(None(), _, _)) // will be translated to either REACHES or SHORTEST 1 in name-analysis.str
                     ; origin-track-forced(!Any())

  to-pathFindingGoal = ( ?Some(AllShortestPathSearch(_, _)) +
                         ?Some(AnyShortestPathSearch(_, _)) +
                         ?Some(AnyShortestPathSearch2(_)) + // deprecated
                         ?Some(CountedShortestPathSearch(_, _, _)) +
                         ?Some(CountedShortestPathSearch2(_)) + // deprecated
                         ?Some(AnyPathSearch(Some(_), _, _)) // translate ANY k to ANY SHORTEST k
                       )
                     ; origin-track-forced(!Shortest())

  to-pathFindingGoal = ( ?Some(AnyCheapestPathSearch(_, _)) +
                         ?Some(AnyCheapestPathSearch2(_)) + // deprecated
                         ?Some(CountedCheapestPathSearch(_, _, _)) +
                         ?Some(CountedCheapestPathSearch2(_)) // deprecated
                       )
                     ; origin-track-forced(!Cheapest())

  to-topKAnyAll = ?None() +
                  ( ?Some(PathModePrefix(_, _)) +
                    ?Some(AllPathSearch(_, _))
                  )
                ; origin-track-forced(!None())

  to-topKAnyAll = ?Some(AllShortestPathSearch(_, _)); origin-track-forced(!Some(All()))

  to-topKAnyAll = ( ?Some(AnyPathSearch(None(), _, _)) +
                    ?Some(AnyShortestPathSearch(_, _)) +
                    ?Some(AnyShortestPathSearch2(_)) + // deprecated
                    ?Some(AnyCheapestPathSearch(_, _)) +
                    ?Some(AnyCheapestPathSearch2(_)) // deprecated
                  )
                ; origin-track-forced(!Some(Any()))

  to-topKAnyAll = ( ?Some(CountedShortestPathSearch(NumberOfPaths(k), _, _)) +
                    ?Some(CountedShortestPathSearch2(NumberOfPaths(k))) + // deprecated
                    ?Some(CountedCheapestPathSearch(NumberOfPaths(k), _, _)) +
                    ?Some(CountedCheapestPathSearch2(NumberOfPaths(k))) + // deprecated
                    ?Some(AnyPathSearch(Some(NumberOfPaths(k)), _, _)) // translate ANY k to ANY SHORTEST k
                  )
                ; origin-track-forced(!Some(TopK(k)))

  to-pathMode = ( ?None() +
                  ?Some(AnyShortestPathSearch2(_)) + // deprecated
                  ?Some(CountedShortestPathSearch2(_)) + // deprecated
                  ?Some(AnyCheapestPathSearch2(_)) + // deprecated
                  ?Some(CountedCheapestPathSearch2(_)) // deprecated
                )
              ; !Walk()

  to-pathMode = ?Some(PathModePrefix(<id>, _)) +
                ( ?Some(AllPathSearch(<id>, _)) +
                  ?Some(AnyPathSearch(_, <id>, _)) +
                  ?Some(AllShortestPathSearch(<id>, _)) +
                  ?Some(AnyShortestPathSearch(<id>, _)) +
                  ?Some(CountedShortestPathSearch(_, <id>, _)) +
                  ?Some(AnyCheapestPathSearch(<id>, _)) +
                  ?Some(CountedCheapestPathSearch(_, <id>, _))
                )
              ; (?None(); !Walk() + ?Some(<id>))

  get-connections-from-quantified-path-patterns(|variable-counter, rowsPerMatch):
    (pathFindingGoal, topKAnyAll, pathMode, pathPattern, otherPaths) ->  <conc> ([path'], edgesTailPaths)
    with edges := <pathPattern-to-connections(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> pathPattern
       ; path' := <?[single-path-only]; !single-path-only; try(single-edge-to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)) <+ !ComplexRegularExpressionNotSupported(<id>, pathFindingGoal)> edges
       ; edgesTailPaths := <get-connections-from-paths(|variable-counter, rowsPerMatch)> otherPaths

  single-edge-to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    edge@NormalizedEdge(srcVertex, e, dstVertex, direction, quantifier, constraints) -> path
    with costClause := None()
       ; path := <to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (srcVertex, dstVertex, edge, constraints, costClause, quantifier)

  pathPattern-to-connections(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    PathPattern(Vertex(n1), edgeVertices@[EdgeVertex(e, Vertex(n2))|_]) -> <conc> ([edge], edgesPathTail)
    with edge := <to-connection(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (n1, e, n2)
       ; edgesPathTail := <get-connections-from-single-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> edgeVertices

  // base case: only one edgeVertex
  get-connections-from-single-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    [EdgeVertex(_, _)] -> []
    
  // two or more edgeVertices
  get-connections-from-single-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    [EdgeVertex(_, Vertex(n1)) | edgeVertices@[EdgeVertex(e, Vertex(n2))|_]]
    -> <conc> ([edge], edgesPathTail)
    with edge := <to-connection(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (n1, e, n2)
       ; edgesPathTail := <get-connections-from-single-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> edgeVertices

  to-connection(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    (n1, edgeOrPath, n2) -> connection
    where <?OutConn(_, quantifier) + ?InConn(_, quantifier) + ?UndirectedEdge(_, quantifier)> edgeOrPath
    with
      switch !edgeOrPath
        case ?OutConn(edgeOrPath', _):
          src := n1;
          dst := n2;
          dir := Outgoing()
        case ?InConn(edgeOrPath', _):
          src := n2;
          dst := n1;
          dir := Incoming()
        case ?UndirectedEdge(edgeOrPath', _):
          src := n1;
          dst := n2;
          dir := Undirected()
        otherwise: fail
      end;
      switch !edgeOrPath'
        case ?ElemContents(Some(e'), _, _, _):
          constraints := <get-inlined-constraints> edgeOrPath'
        ; if <has-at-most-one-binding> quantifier
          then connection := <origin-track-forced(!NormalizedEdge(src, e', dst, dir, quantifier, Constraints(constraints)))> edgeOrPath
          else srcVertex := <unique-name(|variable-counter, edgeOrPath)>
             ; dstVertex := <unique-name(|variable-counter, edgeOrPath)>
             ; edge := <origin-track-forced(!NormalizedEdge(srcVertex, e', dstVertex, dir, None(), Constraints([])))> edgeOrPath
             ; costClause := None()
             ; connection := <to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (n1, n2, edge, Constraints(constraints), costClause, quantifier)
          end
        case ?Path(Some(pathName), pathPatternName, quantifier'):
          connection := Path(src, dst, pathPatternName, quantifier', pathName, dir, Reaches(), -1, pathMode, rowsPerMatch)
        otherwise: fail
      end

  to-connection(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    (n1, t@ParenthesizedPath(RelaxedPathPattern(v1, [RelaxedEdgeVertex(edge, v2)|otherEdges]), whereClause, costClause, quantifier), n2) -> path
    with if <has-at-most-one-binding> quantifier
         then srcVertex := <?Some(Vertex(<id>)) <+ ?None(); !n1> v1
            ; dstVertex := <?Some(Vertex(<id>)) <+ ?None(); !n2> v2
         else srcVertex := <?Some(Vertex(<id>)) <+ ?None(); unique-name(|variable-counter, edge)> v1
            ; dstVertex := <?Some(Vertex(<id>)) <+ ?None(); unique-name(|variable-counter, edge)> v2
         end
       ; edge' := <to-connection(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (srcVertex, edge, dstVertex)
       ; inlinedEdgeConstraints := <?NormalizedEdge(_, _, _, _, _, Constraints(<id>))> edge'
       ; inlinedSrcVertexConstraints := <?Some(Vertex(<id>)); get-inlined-constraints <+ ![]> v1
       ; inlinedDstVertexConstraints := <?Some(Vertex(<id>)); get-inlined-constraints <+ ![]> v2
       ; constraints := <?None(); ![] <+ ?Some(WhereClause(constraint)); ![constraint]> whereClause
       ; constraints' := Constraints(<conc> (inlinedSrcVertexConstraints, inlinedEdgeConstraints, inlinedDstVertexConstraints, constraints))
       ; if <?[]> otherEdges
         then path := <to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch)> (n1, n2, edge', constraints', costClause, quantifier)
         else path := ComplexParenthesizedRegularExpressionNotSupported(otherEdges, pathFindingGoal)
         end

  to-path(|variable-counter, pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch):
    (srcVertex, dstVertex, edge@NormalizedEdge(src, _, dst, direction, _, _), constraints, costClause, quantifier) -> path
    with name := <unique-name(|variable-counter, edge)>
       ; if <?Incoming()> direction
         then vertices := Vertices([Vertex(dst), Vertex(src)])
         else vertices := Vertices([Vertex(src), Vertex(dst)])
         end
       ; edges := Edges([edge])
       ; path-variable-name := <unique-name(|variable-counter, edge)> // for now, all paths are anonymous/generated
       ; commonPathExpression := CommonPathExpression(name, vertices, edges, constraints, costClause)
       ; path := <origin-track-forced(!Path(srcVertex, dstVertex, commonPathExpression, quantifier, path-variable-name, Outgoing(), pathFindingGoal, topKAnyAll, pathMode, rowsPerMatch))> edge

rules

  norm-hop-distance = ?ZeroOrMore(); !BetweenNAndM("0", "-1")
  norm-hop-distance = ?OneOrMore(); !BetweenNAndM("1", "-1")
  norm-hop-distance = ?Optional(); !BetweenNAndM("0", "1")
  norm-hop-distance = ?ExactlyN(n); !BetweenNAndM(n, n)
  norm-hop-distance = ?NOrMore(n); !BetweenNAndM(n, "-1")
  norm-hop-distance = ?BetweenZeroAndM(m); !BetweenNAndM("0", m)

rules

  // pgql 1.3
  norm-query(|error-messages, variable-counter, bindVariableCount):
    Query(commonPathExpressions, selectOrModifyClause, tableExpressionsAndGraphName, groupByClause, havingClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.3", variable-counter, bindVariableCount)> (commonPathExpressions, selectOrModifyClause, optionalGraphName, tableExpressions, whereClause', groupByClause, havingClause, orderByClause, limitOffsets)
    with if <?None()> tableExpressionsAndGraphName
         then optionalGraphName := None()
            ; tableExpressions := []
            ; whereClause' := Constraints([])
         else Some(TableExpressionsAndGraphName(tableExpressions, optionalGraphName, whereClause)) := tableExpressionsAndGraphName
            ; whereClause' := <?Some(WhereClause(<id>)); !Constraints([<id>]) <+ ?None(); !Constraints([])> whereClause
         end

  // pgql 1.1 + 1.2
  norm-query(|error-messages, variable-counter, bindVariableCount):
    Pgql11Query(commonPathExpressions, selectOrModifyClause, fromClause, graphPattern, groupByClause, havingClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.1", variable-counter, bindVariableCount)> (commonPathExpressions, selectOrModifyClause, optionalGraphName, [graphPattern], whereClause, groupByClause, havingClause, orderByClause, limitOffsets)
    with optionalGraphName := <?None() + ?Some(Pgql11FromClause(graphName)); !Some(GraphName(graphName))> fromClause
       ; whereClause := Constraints([]) // WHERE clause is already merged into graphPattern

  // pgql 1.0
  norm-query(|error-messages, variable-counter, bindVariableCount):
    q@Pgql10Query(commonPathExpressions, selectClause, fromClause, graphPattern, groupByClause, orderByClause, limitOffsets) ->
      <norm-query(|error-messages, "v1.0", variable-counter, bindVariableCount)> (commonPathExpressions, selectClause, optionalGraphName, [graphPattern], whereClause, groupByClause, havingClause, orderByClause, limitOffsets)
      with optionalGraphName := <?None() + ?Some(Pgql11FromClause(graphName)); !Some(GraphName(graphName))> fromClause
       ; whereClause := Constraints([]) // WHERE clause is already merged into graphPattern
       ; havingClause := None()

  norm-query(|error-messages, version, variable-counter, bindVariableCount):
    t@(commonPathExpressions, selectOrModifyClause, optionalGraphName, tableExpressions, whereClause, groupByClause, havingClause, orderByClause, limitOffsets) ->
        NormalizedQuery(commonPathExpressions', selectOrModifyClause', optionalGraphName, tableExpressions, whereClause, groupByClause', havingClause, orderByElems, limitOffsets', error-messages, version, bindVariableCount, selectingAllProperties)
    with
      commonPathExpressions' := <map(norm-common-path-expression(|variable-counter)); !CommonPathExpressions(<id>)> commonPathExpressions;

      expAsGroupVars := <?Some(GroupByClause(<id>)) <+ ![]> groupByClause;
      expAsGroupVars' := <map(norm-ExpAsVar)> expAsGroupVars;
      groupByClause' := <?Some(_); !Some(GroupByClause(expAsGroupVars')) <+ !None()> groupByClause;

      selectOrModifyClause' := <?ModifyClause(_) <+ ?SelectClause(_, Star()) <+ ?SelectClause(_, _); norm-SelectList(|version)> selectOrModifyClause;

      orderByElems := <try(norm-orderBy(|version))> orderByClause;

      limitOffsets' := <norm-limitOffsets> limitOffsets;

      selectingAllProperties := <oncetd(?AllProperties(_, _)); !True() <+ !False()> t

  norm-SelectList(|version):
    t1@SelectClause(distinct, t2@SelectList(selectElements)) -> result
    with if <?"v1.0" + ?"v1.1"> version
         then selectElements' := <map(?AllProperties(_, _) + norm-ExpAsVar)> selectElements
         else selectElements' := <map(?AllProperties(_, _) + norm-ExpAsVar-for-select-clause)> selectElements
         end
       ; result := <origin-track-forced(!SelectClause(distinct, <origin-track-forced(!SelectList(selectElements'))> t2))> t1

  norm-ExpAsVar-for-select-clause = ?ExpAsVar(exp@PropRef(_, p), None()); !ExpAsVar(exp, p, NonAnonymous()) <+ norm-ExpAsVar

  norm-ExpAsVar = ?ExpAsVar(exp, Some(VarAssign(v))); !ExpAsVar(exp, v, NonAnonymous())
  norm-ExpAsVar:
    ExpAsVar(exp, None()) -> ExpAsVar(exp, identifier, anonymous)
    with identifier := <(?VarRef(<id>) <+ origin-track-forced(origin-text); origin-track-forced(!Identifier(<id>, <id>)))> exp
       ; anonymous := <?PropRef(_, _); !NonAnonymous() <+ !Anonymous()> exp // 'SELECT n.prop' in PGQL <= 1.2 is 'SELECT n.prop AS "n.prop"' in PGQL 1.3+

  norm-orderBy(|version):
    Some(OrderByClause(elems)) -> Some(OrderByClause(elems'))
    with
      elems' := <map(norm-orderBy-ordering(|version))> elems

  norm-orderBy-ordering(|version) =
    ((?Desc(<id>) + ?Legacy10Desc(<id>)); !OrderByElem(<id>, Desc(), version)) <+
    ((try(?Asc(<id>) + ?Legacy10Asc(<id>))); !OrderByElem(<id>, Asc(), version))

  norm-limitOffsets = ?None(); !LimitOffsetClauses(None(), None())
  norm-limitOffsets = ?Some(LimitOffsetClauses(limitOrFetchFirstClause, optionalOffsetClause)); !LimitOffsetClauses(<norm-limit> Some(limitOrFetchFirstClause), optionalOffsetClause)
  norm-limitOffsets = ?Some(OffsetLimitClauses(offsetClause, optionalLimitOrFetchFirstClause)); !LimitOffsetClauses(<norm-limit> optionalLimitOrFetchFirstClause, Some(offsetClause))

  norm-limit = ?None() + ?Some(LimitClause(_)) + ?Some(FetchFirstClause(_, x, _)); !Some(LimitClause(x))

rules // GRAPH_TABLE

  normalize-table-expression(|variable-counter):
    t@GraphTableDerivedTable(GraphTable(graphName, GraphPattern(PathPatternList(pathPatterns), keepClause, whereClause), GraphTableShape(rowsClause, columnsClause)), correlation)
    -> DerivedTable(Some(GraphTable()), Subquery(
          NormalizedQuery(
            CommonPathExpressions([])
          , selectClause
          , graphName'
          , tableExpressions
          , whereClause'
          , groupBy
          , having
          , orderBy
          , limitOffset
          , errorMessages
          , pgqlVersion
          , bindVariableCount
          , selectingAllProperties
          )
        )
      , correlation)
    with distinct := None()
       ; selectList := <?None(); !t; origin-track-forced(!SelectList([])) <+ // no COLUMNS clause translates to empty COLUMNS clause
                       ?Some(GraphTableColumnsClause(<id>)); map(?AllProperties(_, _) + norm-ExpAsVar-for-select-clause); ?list; !columnsClause; origin-track-forced(!SelectList(list))> columnsClause
       ; selectClause := <origin-track-forced(!SelectClause(distinct, selectList))> selectList
       ; graphName' := <?None() + ?Some(<id>); !Some(GraphName(<id>))> graphName
       ; graphPattern' := <map(!PathPatternAndRowsPerMatch(<id>, rowsClause)); norm-matchElems-common(|variable-counter)> pathPatterns
       ; tableExpressions := [ graphPattern' ]
       ; whereClause' := <?Some(WhereClause(<id>)); !Constraints([<id>]) <+ ?None(); !Constraints([])> whereClause
       ; groupBy := None()
       ; having := None()
       ; orderBy := None()
       ; limitOffset := LimitOffsetClauses(None(), None())
       ; errorMessages := [] // not used
       ; pgqlVersion := "v1.3" // not used
       ; bindVariableCount := -1 // not used
       ; selectingAllProperties := False() // not used
