module check

imports

  stratego/-
  libspoofax/properties/-
  libspoofax/nabl/-
  libspoofax/task/-
  signatures/-
  normalized-signatures
  common
  names/-
  pp
  runtime/properties/-
  runtime/task/-
  type-analysis

rules

  get-pgql-errors:
    AstPlusMetadata(ast, metadata) -> <flatten-list> [errors1, errors2, errors3, errors4]
    with errors1 := <collect(pgql-error)> ast
       ; errors2 := <collect(pgql-error(|metadata); not(?[]))> ast
       ; errors3 := <check-all-GraphTable-restrictions> ast
       ; errors4 := <check-all-restrictions-outside-GraphTable> ast

  generate-error(|m) = !ErrorMessage(<id>, m)

  batch-generate-error(|m) = map(!ErrorMessage(<id>, m))

  pgql-error = ?ErrorMessage(term, message) // for error messages previously generated during normalization

  nabl-check-disable-unresolved = id
  nabl-check-disable-duplicate(|uri, ns) = id

  nabl-constraint(|ctx):
    t@AstPlusMetadata(_, _) -> <fail>
    with <get-pgql-errors; map(to-spoofax-error(|ctx))> t

  nabl-constraint(|ctx) = is-ddl-statement; collect(pgql-error); flatten-list; map(to-spoofax-error(|ctx)); fail

  to-spoofax-error(|ctx):
    ErrorMessage(term, message) -> <id>
    with failtask := <task-create-fail(|ctx)>
       ; <task-create-error-on-failure(|ctx, failtask, message)> term

  get-errors-and-offsets = get-pgql-errors; map(replace-term-by-offset) // invoked from Java only

  replace-term-by-offset = ErrorMessage(origin-offset, id)

rules // Aggregation, unresolved variables, duplicate variables

  pgql-error:
    t@NormalizedQuery(_, _, _, _, _, _, _, _, _, _) -> <not(?[])> errors
    with selectStarElems := <collect(?SelectClause(Star(), SelectList(<id>))); concat> t
       ; group-variables := <filter(get-group-variable-from-select-star)> selectStarElems
       ; errors := <map(generate-error(|$[Cannot select all variables since [<id>] is a group variable but group variables cannot be selected]))> group-variables

  get-group-variable-from-select-star = ?ExpAsVar(ExpressionPlusType(VarRef(Identifier(<id>, _)), _), _, _, _); ?v; origin-text; ?"*"; !v

  pgql-error:
    query@NormalizedQuery(_, selectOrModifyClause, _, _, _, _, _, _, _, _) -> <concat; not(?[])> [errors1, errors2, errors3]
    with group-variables := <collect-in-outer-query(?CommonPathExpression(_, _, _, _, _); get-origin-positions-of-variables); concat> query
       ; aggregations := <get-aggregations> query
       ; varRefs-per-aggregation := <map(origin-track-forced(collect-in-outer-query(?VarRef(_, <id>)); !Some(<id>)))> aggregations
       ; varRefs-per-aggregation-when-multiple := <filter(has-multiple-groupVarRefs(|group-variables))> varRefs-per-aggregation
       ; errors1 := <batch-generate-error(|"Accessing multiple group variables in a single aggregation is not yet supported")> varRefs-per-aggregation-when-multiple

       ; aggregations-contents := <map(get-exp-from-aggregation)> aggregations
       ; nested-aggregations := <map(get-aggregations); concat> aggregations-contents
       ; varRefs-per-nested-aggregation := <map(origin-track-forced(collect-in-outer-query(?VarRef(_, <id>)); !Some(<id>)))> nested-aggregations
       ; varRef-per-nested-aggregation-no-groupVar := <filter(has-no-groupVarRefs(|group-variables))> varRefs-per-nested-aggregation
       ; errors2 := <batch-generate-error(|"Nested aggregation not allowed here")> varRef-per-nested-aggregation-no-groupVar

       ; if <?SelectClause(_, SelectList(expAsVars))> selectOrModifyClause
         then aggregations-contents-in-select := <filter(?ExpAsVar(ExpressionPlusType(<get-exp-from-aggregation>, _), _, _, _))> expAsVars
            ; varRefs-per-aggregation-in-select := <map(origin-track-forced(collect-in-outer-query-outside-aggregation(?VarRef(_, <id>)); !Some(<id>)))> aggregations-contents-in-select
            ; varRef-per-aggregation-no-groupVar-in-select := <filter(has-no-groupVarRefs(|group-variables))> varRefs-per-aggregation-in-select
            ; if <gt> (<length> varRefs-per-aggregation-in-select, <length> varRef-per-aggregation-no-groupVar-in-select)
              then errors3 := <batch-generate-error(|"Aggregation with group variables expected since SELECT clause has another aggregation with group variables")> varRef-per-aggregation-no-groupVar-in-select
              else errors3 := []
              end
         else errors3 := []
         end

   pgql-error:
    t@Constraints(_) -> <not(?[])> errors
    with
      aggregations := <get-aggregations-without-group-variables> t;
      errors := <batch-generate-error(|"Aggregation without group variables not allowed in WHERE")> aggregations

  pgql-error:
   t@GroupByClause(_) -> <not(?[])> errors
    with
      aggregations := <get-aggregations-without-group-variables> t;
      errors := <batch-generate-error(|"Aggregation without group variables not allowed in GROUP BY")> aggregations

  get-aggregations-without-group-variables = get-aggregations; filter(not(contains-varRef + contains-nested-aggregation))

  pgql-error:
    NormalizedQuery(_, selectOrModifyClauseWithAnnos, _, tableExpressionsWithAnnos, _, groupClauseWithAnnos, _, _, _, _) -> <concat; not(?[])> [errors1, errors2, errors3, errors4, errors5, errors6, errors7]
    with selectOrModifyClause := <strip-annos> selectOrModifyClauseWithAnnos
       ; tableExpressions := <strip-annos> tableExpressionsWithAnnos
       ; groupClause := <strip-annos> groupClauseWithAnnos
       ; vars := <map(collect-vars-from-table-expression); concat> tableExpressions
       ; if <?Some(_)> groupClause
         then groupVars := <?Some(GroupByClause(<id>)); map(?ExpAsVar(_, Identifier(<id>, _), _, _))> groupClause
         else groupVars := []
         end
       ; errors1 := <generate-error-on-duplicates(|"Duplicate variable")> vars
       ; errors2 := <generate-error-on-duplicates(|"Duplicate column name in GROUP BY")> groupVars
       ; if <?SelectClause(_, _)> selectOrModifyClause
         then selectVars := <collect-om(?ExpAsVar(_, Identifier(<id>, _), _, _), conc)> selectOrModifyClause // for e.g. SELECT n.age, n.AgE
            ; duplicateSelectVarError := "Duplicate column name in SELECT"
            ; errors3 := <generate-error-on-duplicates(|duplicateSelectVarError)> selectVars
            ; selectVarsOriginText := <collect-om(?ExpAsVar(_, Identifier(_, <id>), _, _), conc)> selectOrModifyClause // for e.g. SELECT n.age, n."age"
            ; errors4 := <generate-error-on-duplicates(|duplicateSelectVarError)> selectVarsOriginText
            ; insertVars := []
            ; errors5 := []
         else // MODIFY query
              insertVars := <collect-om(?VertexInsertion(Identifier(<id>, _), _, _, _) + ?DirectedEdgeInsertion(Identifier(<id>, _), _, _, _, _, _), conc)> selectOrModifyClause
            ; errors3 := <generate-error-on-duplicates(|"Duplicate variable in INSERT")> insertVars
            ; updateVars := <collect-om(?Update(ExpressionPlusType(VarRef(Identifier(<id>, _)), _), _) + ?Update(ExpressionPlusType(VarRef(Identifier(<id>, _), _), _), _), conc)> selectOrModifyClause
            ; updates-of-inserts := <isect> (updateVars, insertVars)
            ; errors4 := <batch-generate-error(|"Cannot update an element that is being inserted")> updates-of-inserts
            ; deleteVars := <(collect-one(?DeleteClause(<id>)) <+ ![]); filter(?ExpressionPlusType(VarRef(Identifier(<id>, _), _), _))> selectOrModifyClause
            ; sourceVertices := <collect-om(?DirectedEdgeInsertion(_, _, ExpressionPlusType(VarRef(Identifier(<id>, _), _), _), _, _, _), conc)> selectOrModifyClause
            ; destinationVertices := <collect-om(?DirectedEdgeInsertion(_, _, _, ExpressionPlusType(VarRef(Identifier(<id>, _), _), _), _, _), conc)> selectOrModifyClause
            ; all-updateVars := <conc> (updateVars, sourceVertices, destinationVertices)
            ; deletes-of-updates := <isect> (all-updateVars, deleteVars)
            ; errors5 := <batch-generate-error(|"Element is deleted in DELETE clause")> deletes-of-updates
         end

       ; if <?Some(_)> groupClause
         then nonAnonymousGroupVars := <?Some(GroupByClause(<id>)); filter(?ExpAsVar(_, Identifier(<id>, _), NonAnonymous(), _))> groupClause
         else nonAnonymousGroupVars := []
         end
       ; redefinitions-in-groupBy := <isect> (nonAnonymousGroupVars, vars)
       ; errors6 := <batch-generate-error(|"Duplicate variable: variable already defined in the FROM clause")> redefinitions-in-groupBy

       ; if <?None()> groupClause
         then redefinition-in-modify := <isect> (insertVars, vars)
            ; errors7 := <batch-generate-error(|"Duplicate variable: variable already defined in the FROM clause")> redefinition-in-modify
         else if <?ModifyClause(_)> selectOrModifyClause
              then redefinitions-in-modify := <isect> (insertVars, nonAnonymousGroupVars)
                 ; errors7 := <batch-generate-error(|"Duplicate variable: variable already defined in the GROUP BY clause")> redefinitions-in-modify
              else errors7 := []
              end
         end

  pgql-error:
    query@NormalizedQuery(_, selectClause, _, _, _, group-by, having, order-by, _, _) -> <concat; not(?[])> [errors1, errors2]
    with unresolved-vars := <collect-in-outer-query(?VarRef(<id>))> query
        ; if None() := group-by
          then errors1 := <batch-generate-error(|"Unresolved variable")> unresolved-vars
             ; errors2 := []
          else unresolved-vars-after-grouping := <collect-in-outer-query-outside-aggregation(?VarRef(<id>))> (selectClause, having, order-by)
             ; other-unresolved-vars := <diff> (unresolved-vars, unresolved-vars-after-grouping)
             ; errors1 := <batch-generate-error(|"Unresolved variable")> other-unresolved-vars
             ; if CreateOneGroup() := group-by // aggregation without GROUP BY
               then errors2 := <batch-generate-error(|"Unresolved variable (did you mean to use an aggregation?)")> unresolved-vars-after-grouping
               else errors2 := <batch-generate-error(|"Unresolved variable (did you mean to use a group key?)")> unresolved-vars-after-grouping
               end
          end

  contains-varRef = oncetd(?VarRef(_, _))

  contains-nested-aggregation = where (get-exp-from-aggregation; get-aggregations; not(?[]))

  get-origin-positions-of-variables:
    CommonPathExpression(_, Vertices(vertices), Edges(edges), _, _) -> <conc; make-set> (origins-of-vertices, origins-of-edges)
    with origins-of-vertices := <map(?Vertex(_, <id>, _, _))> vertices
       ; origins-of-edges := <filter(?Edge(_, _, _, _, <id>, _, _))> edges

  has-multiple-groupVarRefs(|group-variables):
    t@Some(varRefs-in-aggregation) -> t
    where group-varRefs := <isect; not(?[] + ?[_])> (group-variables, varRefs-in-aggregation)

  has-no-groupVarRefs(|group-variables):
    t@Some(varRefs-in-aggregation) -> <id>
    where group-varRefs := <isect; ?[]> (group-variables, varRefs-in-aggregation)

  generate-error-on-duplicates(|message) = ?vars; filter(generate-error-on-duplicate(|vars, message))

  generate-error-on-duplicate(|vars, message):
    var -> error
    with vars' := <filter(?var)> vars
    where error := <gt; !var; generate-error(|message)> (<length> vars', 1)

rules // in-lined constraints

  pgql-error:
    ReferenceInInlinedConstraint(v) -> error
    with
      error := <generate-error(|$['[v]' should be omitted here])> v

  pgql-error:
    CrossReferenceInInlinedConstraint(v) -> error
    with
      error := <generate-error(|$['[v]' is not visible here])> v

rules // vertex in WHERE without rounded brackets

  pgql-error:
    Vertex(v, _, _, _) -> error
    where
      <string-ends-with(|<VERTEX_WITHOUT_BRACKETS>)> v
    with
      error := <generate-error(|$<Vertices need to be surrounded by brackets: (<<origin-text> v>)>)> v

rules

  pgql-error:
    NormalizedQuery(_, SelectClause(_, SelectList(selectElements)), _, _, _, groupClause, havingClause, orderByClause, _, _) -> <not(?[])> errors
    where
      None() := groupClause
    ; [] := <get-aggregations> selectElements // there are no aggregations in the SELECT
    with
      aggregations-in-orderByclause := <get-aggregations> orderByClause
    ; errors := <batch-generate-error(|"Aggregation in ORDER BY only allowed if SELECT has aggregations")> aggregations-in-orderByclause

  // if SELECT DISTINCT then ORDER BY expressions may only be repetitions of expressions in SELECT
  pgql-error:
    NormalizedQuery(_, SelectClause(Some(Distinct()), SelectList(selectElements)), _, _, _, _, _, Some(OrderByClause(order-by-elems)), _, _) -> <not(?[])> errors
    with
      select-vars := <map(?ExpAsVar(_, Identifier(<id>, _), _, _)); strip-annos> selectElements
    ; order-by-expressions := <map(?OrderByElem(<id>, _, _)); strip-annos> order-by-elems
    ; order-by-expressions-not-in-select := <remove-all(?ExpressionPlusType(VarRef(Identifier(<id>, _), _), _); !(<id>, select-vars); elem)> order-by-expressions
    ; errors := <batch-generate-error(|"Because of DISTINCT projection, the expression in ORDER BY should be one of the expressions in the SELECT")> order-by-expressions-not-in-select

  pgql-error:
    e@IllegalNull() -> error
    with error := <generate-error(|"Use IS NULL or IS NOT NULL")> e

  pgql-error:
    SelectClause(GroupBySelectStar(), e) -> error
    with error := <generate-error(|"SELECT * not allowed in combination with GROUP BY")> e

  pgql-error:
    NormalizedQuery(_, SelectClause(Star(), e@SelectList([])), _, tableExpressions, _, _, _, _, _, _) -> error
    where <not(oncetd(?AllProperties(_, _)))> tableExpressions // to allow for parsing and pretty printing when no metadata is available, we only generate the error if no lateral derived table contains an n.* because then we don't know how many elements the SELECT * would have
    with error := <generate-error(|"SELECT * not allowed if there are no variables in the graph pattern")> e

  pgql-error:
    COUNT(Some(Distinct()), e@Star()) -> error
    with error := <generate-error(|"* not allowed in combination with DISTINCT")> e

rules // subqueries

  pgql-error:
    q@NormalizedQuery(_, _, _, _, _, _, _, _, _, _) -> <concat; not(?[])> [errors1, errors2]
    with scalarSubqueries := <collect(?Exists(_) + ?DerivedTable(_, _, _) + ?Subquery(_)); remove-all(?Exists(_) + ?DerivedTable(_, _, _))> q
       ; multiColumnScalarSubqueries := <filter(is-multi-column-subquery)> scalarSubqueries
       ; zeroColumnScalarSubqueries := <filter(is-zero-column-subquery)> scalarSubqueries
       ; errors1 := <batch-generate-error(|"Scalar subquery is expected to return a single column, but multiple columns were returned")> multiColumnScalarSubqueries
       ; errors2 := <batch-generate-error(|"Scalar subquery is expected to return a single column, but zero columns were returned")> zeroColumnScalarSubqueries

  is-multi-column-subquery = ?Subquery(NormalizedQuery(_, SelectClause(_, e@SelectList(selectElements)), _, _, _, _, _, _, _, _))
                           ; where( <gt> (<length> selectElements, 1) ); !e

  is-zero-column-subquery = ?Subquery(NormalizedQuery(_, SelectClause(_, e@SelectList(selectElements)), _, _, _, _, _, _, _, _))
                           ; where( <eq> (<length> selectElements, 0) ); !e

  pgql-error:
    Subquery(NormalizedQuery(_, t@selectOrUpdateClause, _, _, _, _, _, _, _, _)) -> error
    where not ( <?SelectClause(_, _)> selectOrUpdateClause )
    with error := <generate-error(|"SELECT clause expected here")> t

  pgql-error:
    t@NormalizedQuery(_, _, _, _, _, _, _, _, _, QueryAnnotations(_, "v1.3", _, _, _)) -> <not(?[])> errors
    with nonPgql13Subqueries := <collect(is-non-pgql13-query)> t
       ; errors := <map(get-select-clause); batch-generate-error(|"Subquery uses older version of PGQL syntax; please make sure that both inner and outer query use the same PGQL version")> nonPgql13Subqueries

  pgql-error:
    t -> <not(?[])> errors
    where <is-non-pgql13-query> t
    with pgql13Subqueries := <collect(is-pgql13-query)> t
       ; errors := <map(get-select-clause); batch-generate-error(|"Subquery uses PGQL 1.3 syntax but outer query does not")> pgql13Subqueries

  is-pgql13-query = ?NormalizedQuery(_, _, _, _, _, _, _, _, _, QueryAnnotations(_, "v1.3", _, _, _))

  is-non-pgql13-query = ?NormalizedQuery(_, _, _, _, _, _, _, _, _,  QueryAnnotations(_, version, _, _, _)); where (!version; not(?"v1.3"))

  get-select-clause = ?NormalizedQuery(_, <id>, _, _, _, _, _, _, _, _)

  pgql-error:
    ScalarSubquery(Subquery(NormalizedQuery(_, SelectClause(_, SelectList([ExpAsVar(ExpressionPlusType(exp, Type(t, _)), _, _, _)])), _, _, _, _, _, _, _, _))) -> error
    where <?"VERTEX" + ?"EDGE"> t
    with error := <generate-error(|"Scalar subquery not allowed to return a vertex or an edge")> exp

  pgql-error:
    t@DerivedTable(None(), _, _) -> error
    with error := <generate-error(|"LATERAL keyword expected at start of derived table expression")> t

  pgql-error:
    DerivedTable(_, _, t@Some(_)) -> error
    with error := <generate-error(|"Unsupported correlation name for derived table")> t

rules // temporary limitation

  pgql-error:
    ComplexRegularExpressionNotSupported(edgesOrPaths, pathFindingGoal) -> error
    with [_|[secondEdgeOrPath|_]] := edgesOrPaths
       ; error := <generate-error-for-multiple-edge-patterns(|pathFindingGoal)> edgesOrPaths

  pgql-error:
    ComplexParenthesizedRegularExpressionNotSupported(edges, pathFindingGoal) -> error
    with error := <generate-error-for-multiple-edge-patterns(|pathFindingGoal)> edges

  generate-error-for-multiple-edge-patterns(|pathFindingGoal):
    edgesOrPaths -> error
    with if <?All()> pathFindingGoal
         then error := <generate-error(|"Not supported: path pattern containing multiple edge patterns in combination with quantifier(s); please split up the pattern into multiple path patterns")> edgesOrPaths
         else error := <generate-error(|"Not supported: path pattern containing multiple edge patterns in combination with ANY, SHORTEST or CHEAPEST; try splitting up the pattern into multiple path patterns")> edgesOrPaths
         end

  pgql-error:
    Path(_, _, _, _, _, _, _, Some(TopK(kValue)), _, _) -> error
    where <?"0"> kValue
    with error := <generate-error(|"Value should be greater than 0")> kValue

  pgql-error:
    Path(_, _, pathExpression, quantifier, _, _, goal, _, _, _) -> error
    where <?Shortest() + ?Cheapest() + ?Any() + ?All()> goal
        ; <?None() + ?Some(BetweenNAndM("0", "1")); origin-text; ?"?"> quantifier
    with error-term := <?Some(_) <+ !pathExpression; collect-one(?Edge(_, _, _, _, _, _, _))> quantifier 
       ; if <?All()> goal
         then error := <generate-error(|"Quantifier of the form {1,4} expected")> error-term
         else error := <generate-error(|"Quantifier of the form * or + or {1,4} expected")> error-term
         end

  pgql-error:
    Path(_, _, pathExpression, quantifier, _, _, goal, _, Walk(), _) -> error
    where <?All()> goal
        ; <?Some(BetweenNAndM(_, "-1"))> quantifier
    with error := <generate-error(|"Potentially infinite solutions; specify a selective path-finding goal or a quantifier with upper bound")> quantifier

  pgql-error:
    t@CommonPathExpression(_, _, connections, _, _) -> error
    where <collect-in-outer-query(?Path(_, _, _, _, _, _, _, _, _, _)); not(?[])> connections
    with error := <generate-error(|"Nested regular expressions not supported")> t

  pgql-error:
    t@LabelDisjunction(_, _) -> error
    with error := <generate-error(|"Label disjunction not supported here")> t

rules

  pgql-error:
    Path(_, _, _, _, Identifier(i, _), _, _, _, _, _) -> error
    where <not(is-substring(GENERATED))> i
    with error := <generate-error(|"Path variables not supported")> i

rules // CHEAPEST

  pgql-error:
    t@Path(_, _, CommonPathExpression(_, _, _, Constraints(constraints), costClause), _, _, _, Cheapest(), _, _, _) -> error
    where <?None()> costClause
    with if <?[]> constraints
    then error := <generate-error(|"COST clause expected after pattern")> t
    else error := <?[<id>]; generate-error(|"COST clause expected after WHERE clause")> constraints
    end

  pgql-error:
    t@Path(_, _, CommonPathExpression(_, vertices, edges, _, Some(CostClause(costExpression))), _, _, _, Cheapest(), _, _, _) -> errors
    where <?Vertices([Vertex(v1, _, _, _), Vertex(v2, _, _, _)])> vertices
        ; <?Edges([Edge(_, e, _, _, _, _, _)])> edges
    with variablesDefs := [v1, v2, e]
       ; errors := <generate-error-on-cross-constraint(|variablesDefs); flatten-list> costExpression
    where <not(?[])> errors

  generate-error-on-cross-constraint(|variablesDefs):
    t@And(lhs, rhs) -> [errors1, errors2]
    with errors1 := <generate-error-on-cross-constraint(|variablesDefs)> lhs
       ; errors2 := <generate-error-on-cross-constraint(|variablesDefs)> rhs

  generate-error-on-cross-constraint(|variablesDefs):
    t -> errors
    where <not(?And(_, _))> t
    with variables := <collect(?VarRef(<id>, _) + ?Vertex(<id>, _, _, _) + ?Edge(_, <id>, _, _, _, _, _) + ?Path(_, _, _, _, <id>, _, _, _, _, _))> t
       ; variableRefs := <strip-annos; isect> (variablesDefs, variables)
       ; errors := <!(<length> variableRefs, 1); gt; !t; generate-error(|"Not yet supported: expressions with multiple variables"); ![<id>] <+ ![]> t

  pgql-error:
    Path(_, _, CommonPathExpression(_, _, _, _, Some(t@CostClause(_))), _, _, _, pathFindingGoal, _, _, _) -> error
    where not ( <?Cheapest()> pathFindingGoal )
    with error := <generate-error(|"COST clause only allowed in combination with CHEAPEST")> t

  pgql-error(|metadata):
    CostClause(ExpressionPlusType(exp, type@Type(t, _))) -> error
    where <get-union-type(|metadata); ?AmbiguousType()> (type, <get-default-decimal-type(|metadata)>)
    with error := <generate-error(|$<COST clause expects a numeric but a <t> was given>)> exp

rules // literals

  external is-invalid-datetime(|)

  pgql-error:
    datetime-> error
    where <(?Date(_) + ?Time(_) + ?Timestamp(_)); is-invalid-datetime; ?ErrorMessage(_, m)> datetime
    with error := <generate-error(|m)> datetime

  pgql-error:
    t@NormalizedQuery(_, _, _, _, _, _, _, _, _, QueryAnnotations(_, pgqlVersion, _, _, _)) -> <not(?[])> errors
    where not ( <?"v1.0" + ?"v1.1"> pgqlVersion )
    with errors := <collect-in-outer-query(check-illegal-java-escaping)> t

  check-illegal-java-escaping:
    t@String(s) -> error
    where <is-substring(!"\\'")> s
    with error := <generate-error(|"Use '' instead of \\' to escape a single quote")> t

  check-illegal-java-escaping:
    t@Identifier(identifier, _) -> error
    where <is-substring(!"\\\"")> identifier
    with error := <generate-error(|"Use \"\" instead of \\\" to escape a double quote")> t

  pgql-error:
    DateTimeField(field) -> error
    where <not(?"YEAR" + ?"MONTH" + ?"DAY" + ?"HOUR" + ?"MINUTE" + ?"SECOND")> field
    with error := <generate-error(|"Expecting one of YEAR, MONTH, DAY, HOUR, MINUTE, SECOND")> field

  pgql-error:
    Interval(t@String(value), DateTimeField(field))-> error
    where <is-invalid-datetime-field; ?ErrorMessage(_, m)> (value, field)
    with error := <generate-error(|m)> t

  external is-invalid-datetime-field(|)

rules // IN predicate and CASE expression

  pgql-error(|metadata):
    inPredicate@InPredicate(exp, Array(valueExpressions)) -> <not(?[])> [error1|errors2]
    where [x|xs] := valueExpressions
        ; <?ExpressionPlusType(_, Type(t2, _))> := x
    with // check that type of expression on left-hand of IN is compatible with expression of list elements
         if <?ExpressionPlusType(_, Type(t1, _)); not(is-compatible-type(|x, metadata))> exp
         then error1 := <generate-error(|$[The IN predicate is undefined for left-hand operand type [t1] and list value type [t2]])> inPredicate
         else error1 := []
         end

         // check that values in the list are of compatible type
       ; incompatible-expressions := <remove-all(is-compatible-type(|x, metadata))> xs
       ; errors2 := <map(generate-compatible-type-expected-error(|t2))> incompatible-expressions

  generate-compatible-type-expected-error(|expectedType) =
    ?ExpressionPlusType(<id>, Type(t, _));
    generate-error(|$<Expression of a type compatible with <expectedType> expected but a <t> was given>)

  pgql-error:
    IfElse(ExpressionPlusType(exp, Type(t, _)), _, _) -> error
    where <not(?"BOOLEAN")> t
    with error := <generate-error(|$<BOOLEAN expected but a <t> was given>)> exp

  pgql-error(|metadata):
   ExpressionPlusType(IfElse(_, ExpressionPlusType(_, type1@Type(t1, _)), elseExpPlusType@ExpressionPlusType(_, Type(_, _))), AmbiguousType()) -> error
   with error := <generate-compatible-type-expected-error(|t1)> elseExpPlusType

  pgql-error:
    SimpleCase(ExpressionPlusType(exp, Type(t, _)), _, _, _) -> error
    where <is-unsupported-CASE-type> t
    with error := <generate-error(|$[CASE does not allow [t] input])> exp

  pgql-error:
    IfElse(if, then, else) ->error
    where <?ExpressionPlusType(thenExp, Type(<id>, _)); ?thenType; is-unsupported-CASE-type> then
    with error := <generate-error(|$[CASE does not allow [thenType] output])> thenExp

  pgql-error:
    IfElse(if, then, else) -> error
    where <?ExpressionPlusType(elseExp, Type(<id>, _)); ?elseType; is-unsupported-CASE-type> else
    with error := <generate-error(|$[CASE does not allow [elseType] output])> elseExp

  is-unsupported-CASE-type = ?"VERTEX" + ?"EDGE" + string-starts-with(|"ARRAY<") + string-starts-with(|"SET<")

rules // IS SOURCE OF and IS DESTINATION OF

  pgql-error:
    SourceDestinationPredicate(ExpressionPlusType(exp1, Type(t1, _)), _, _) -> error
    where <not(?"VERTEX")> t1
    with error := <generate-error(|"Vertex reference expected")> exp1

  pgql-error:
    SourceDestinationPredicate(_, ExpressionPlusType(exp2, Type(t2, _)), _) -> error
    where <not(?"EDGE")> t2
    with error := <generate-error(|"Edge reference expected")> exp2

rules // SELECT

  pgql-error:
    NormalizedQuery(_, t@SelectClause(_, _), _, [], _, _, _, _, _, _) -> error
    with error := <generate-error(|"SELECT query without FROM clause not supported")> t

rules // MODIFY

  // e.g. UPDATE x.prop = 123 ... GROUP BY x.prop
  pgql-error:
    SetProperty(ExpressionPlusType(t@VarRef(_, _), _), _) -> error
    with error := <generate-error(|"Cannot set a property that is grouped by")> t

  // setting a property twice, in either UPDATE or INSERT
  pgql-error:
    properties -> <not(?[])> errors
    where <?SetProperties(setPropertyExps) + ?Properties(setPropertyExps)> properties
    with propertyRefs := <filter(?SetProperty(ExpressionPlusType(PropRef(_, Identifier(<id>, _)), _), _))> setPropertyExps
       ; duplicatePropertyRefs := <filter(is-elem-contained-more-than-once(|propertyRefs))> propertyRefs
       ; errors := <batch-generate-error(|"Property is set multiple times")> duplicatePropertyRefs

  is-elem-contained-more-than-once(|elems):
    elem -> <id>
    where duplicates := <filter(?elem)> elems
        ; <gt> (<length>, 1)

  pgql-error:
    UpdateClause(updates) -> <not(?[])> errors
    with updateElements := <filter(?Update(ExpressionPlusType(VarRef(Identifier(<id>, _), _), _), _))> updates
       ; duplicateUpdateElements := <filter(is-elem-contained-more-than-once(|updateElements))> updateElements
       ; errors := <batch-generate-error(|"Element is updated multiple times (merge the two updates together)")> duplicateUpdateElements

  pgql-error:
    DeleteClause(deletions) -> <not(?[])> errors
    with deleteElements := <filter(?ExpressionPlusType(VarRef(Identifier(<id>, _), _), _))> deletions
       ; duplicateDeleteElements := <filter(is-elem-contained-more-than-once(|deleteElements))> deleteElements
       ; errors := <batch-generate-error(|"Element is deleted multiple times")> duplicateDeleteElements

  pgql-error:
    t -> <not(?[])> errors
    where <?VertexInsertion(Identifier(v, originText), _, _, Some(Properties(setProperties))) +
           ?DirectedEdgeInsertion(Identifier(v, originText), _, _, _, _, Some(Properties(setProperties))) +
           ?Update(ExpressionPlusType(VarRef(Identifier(v, originText), _), _), SetProperties(setProperties))> t
    with v' := <strip-annos> v
       ; otherVariablesThanV := <filter(?SetProperty(ExpressionPlusType(PropRef(VarRef(Identifier(<id>, _), _), _), _), _); strip-annos; not(?v'))> setProperties
       ; if <eq> (v', <strip-annos> originText)
         then varNameAsString := <origin-text> v
         else varNameAsString := originText // using <origin-text> like above fails SPT tests, thus we avoid using it for unquoted identifier so that we at least can still use unquoted identifiers in INSERT/UPDATE queries in SPT
         end
       ; errors := <batch-generate-error(|$<Did you mean <varNameAsString>?>)> otherVariablesThanV

  pgql-error:
    ModifyClause(insertUpdateDeleteClauses) -> <concat; not(?[])> [errors1, errors2, errors3]
    with additionalInsertClauses := <filter(?InsertClause(_, _)); try(Tl)> insertUpdateDeleteClauses
       ; additionalUpdateClauses := <filter(?UpdateClause(_)); try(Tl)> insertUpdateDeleteClauses
       ; additionalDeleteClauses := <filter(?DeleteClause(_)); try(Tl)> insertUpdateDeleteClauses
       ; errors1 := <batch-generate-error(|"Only a single INSERT clause is allowed per query; use commas to insert multiple elements in a single INSERT clause")> additionalInsertClauses
       ; errors2 := <batch-generate-error(|"Only a single UPDATE clause is allowed per query; use commas to update multiple elements in a single UPDATE clause")> additionalUpdateClauses
       ; errors3 := <batch-generate-error(|"Only a single DELETE clause is allowed per query; use commas to delete multiple elements in a single DELETE clause")> additionalDeleteClauses

  pgql-error:
    SetProperty(_, ExpressionPlusType(exp, Type(t, _))) -> error
    where <?"VERTEX" + ?"EDGE"> t
    with error := <generate-error(|"Cannot set the value of a property to a vertex or an edge")> exp

// CREATE PROPERTY GRAPH

  pgql-error:
    CreatePropertyGraph(_, baseGraphs, VertexTables(vertexTables), EdgeTables(edgeTables), _) -> <concat; not(?[])> [errors1, errors2, errors3, errors4]
    with elementTableNamesFromBaseGraphs := <collect-om(?BaseElementTable(_, <id>); to-identifier-without-origin-info, conc)> baseGraphs
       ; vertexTableNames := <map(?VertexTable(_, <id>, _, _); to-identifier-without-origin-info)> vertexTables
       ; errors1 := <generate-error-on-duplicates(|"Duplicate vertex table name; use an alias to make the vertex table name unique (table AS alias)")> vertexTableNames
       ; edgeTableNames := <map(?EdgeTable(_, <id>, _, _, _, _); to-identifier-without-origin-info)> edgeTables
       ; errors2 := <generate-error-on-duplicates(|"Duplicate edge table name; use an alias to make the edge table name unique (table AS alias)")> edgeTableNames
       ; elementTableNames := <conc> (elementTableNamesFromBaseGraphs, <conc; make-set> (vertexTableNames, edgeTableNames))
       ; errors3 := <generate-error-on-duplicates(|"Duplicate element table name; use an alias to make the element table name unique (table AS alias)")> elementTableNames

       ; if <?None()> baseGraphs
         then // check for unresolved references from edge tables to vertex tables
              // we only do so if there are no base graphs
              vertexTableReferences := <collect(( ?SourceVertexTable(_, ReferencedVertexTable(Name(_, <id>), _)) +
                                                  ?DestinationVertexTable(_, ReferencedVertexTable(Name(_, <id>), _))
                                                ); to-identifier-without-origin-info)> edgeTables
            ; unresolvedVertexTableReferences := <diff> (vertexTableReferences, vertexTableNames)
            ; errors4 := <batch-generate-error(|"Undefined vertex table")> unresolvedVertexTableReferences
         else // check for duplicate base graphs
              baseGraphNames := <?Some(BaseGraphs(<id>)); map(?BaseGraph(<id>, _)); alltd(to-identifier-without-origin-info)> baseGraphs
            ; errors4 := <generate-error-on-duplicates(|"Duplicate base graph reference")> baseGraphNames
         end

  to-identifier-without-origin-info = origin-track-forced(?Identifier(localName, _); !localName)

  pgql-error:
    PropertyExpressions(expAsVars) -> <concat; not(?[])> [errors1, errors2]
    with complexExpressionsWithoutAlias := <remove-all(?ExpAsVar(VarRef(_), _) + ?ExpAsVar(_, Identifier(_, _)))> expAsVars
       ; errors1 := <batch-generate-error(|"Alias required (.. AS name)")> complexExpressionsWithoutAlias
       ; propertyNames := <filter(?ExpAsVar(_, Identifier(<id>, _)))> expAsVars
       ; errors2 := <generate-error-on-duplicates(|"Duplicate property name")> propertyNames

  pgql-error:
    ReferencedVertexTable(Name(Some(schemaName), _), _) -> error
    with error := <generate-error(|"Schema name not allowed here")> schemaName

  pgql-error:
    t -> error
    where <?SourceVertexTable(None(), ReferencedVertexTable(_, Some(_))) + ?DestinationVertexTable(None(), ReferencedVertexTable(_, Some(_)))> t
    with error := <generate-error(|"Referenced column list provided but no KEY clause specified")> t

// LISTAGG

  pgql-error:
    LISTAGG(_, _, Some(Separator(separator))) -> error
    where not ( <?String(_)> separator )
    with error := <generate-error(|"Only string literals are allowed as separator")> separator

// schema

  pgql-error(|metadata):
    ast -> <concat; not(?[])> [errors1, errors2]
    with vertexDefinititions := <collect(?Vertex(_, <id>, _, _))> ast
       ; vertexLabels := <get-vertex-labels(|metadata)>
       ; if <not(?None())> vertexLabels
         then unresolvedVertexLabels := <collect(get-unresolved-label(|vertexDefinititions, vertexLabels))> ast
            ; errors1 := <batch-generate-error(|"Vertex label does not exist")> unresolvedVertexLabels
         else errors1 := []
         end
       ; edgeDefinititions := <collect(?Edge(_, _, _, _, <id>, _, _))> ast
       ; edgeLabels := <get-edge-labels(|metadata)>
       ; if <not(?None())> edgeLabels
         then unresolvedEdgeLabels := <collect(get-unresolved-label(|edgeDefinititions, edgeLabels))> ast
            ; errors2 := <batch-generate-error(|"Edge label does not exist")> unresolvedEdgeLabels
         else errors2 := []
         end

  get-unresolved-label(|varDefinitionOriginOffsets, labels):
    FunctionCall(None(), Identifier(functionName, _), [ ExpressionPlusType(VarRef(_, originOffset), _), identifierOrString ]) -> labelReference
    where <?"has_label" + ?"HAS_LABEL"> functionName
        ; labelReference := <?Identifier(<id>, _) + ?ExpressionPlusType(String(<id>), _)> identifierOrString
        ; <elem> (originOffset, varDefinitionOriginOffsets)
        ; <not(label-exists(|labels))> labelReference

  pgql-error(|metadata):
    VertexInsertion(_, _, Some(Labels(labels)), _) -> <not(?[])> errors
    where vertexLabels := <get-vertex-labels(|metadata); not(?None())>
    with unresolvedVertexLabels := <map(?Identifier(<id>, _)); remove-all(label-exists(|vertexLabels))> labels
       ; errors := <batch-generate-error(|"Vertex label does not exist")> unresolvedVertexLabels

  pgql-error(|metadata):
     DirectedEdgeInsertion(_, _, _, _, Some(Labels(labels)), _) -> <not(?[])> errors
     where edgeLabels := <get-edge-labels(|metadata); not(?None())>
     with unresolvedEdgeLabels := <map(?Identifier(<id>, _)); remove-all(label-exists(|edgeLabels))> labels
        ; errors := <batch-generate-error(|"Edge label does not exist")> unresolvedEdgeLabels

  label-exists(|labels):
    labelReference -> <id>
    where <elem + elem-when-upper-cased> (labelReference, labels)

  elem-when-upper-cased = (id, map(upper-case)); elem

  pgql-error:
    ExpressionPlusType(PropRef(_, Identifier(propName, _)), Undefined()) -> error
    with error := <generate-error(|$[Property does not exist for any of the labels])> propName

  pgql-error:
    ExpressionPlusType(PropRef(_, Identifier(propName, _)), AmbiguousType()) -> error
    with error := <generate-error(|$[Property has incompatible types for different labels])> propName

  pgql-error:
    ExpressionPlusType(e@UMin(ExpressionPlusType(_, Type(t, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator - (unary minus) is undefined for the argument type [t]])> e

  pgql-error:
    ExpressionPlusType(e@Not(ExpressionPlusType(_, Type(t, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator NOT is undefined for the argument type [t]])> e

  pgql-error:
    ExpressionPlusType(e@And(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator AND is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Or(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator OR is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Mul(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator * is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Add(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator + is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Div(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator / is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Mod(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator % is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Sub(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator - is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Eq(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator = is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Neq(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator <> (or !=) is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Gt(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator > is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Lt(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator < is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Gte(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator >= is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Lte(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator <= is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(e@Cct(ExpressionPlusType(_, Type(t1, _)), ExpressionPlusType(_, Type(t2, _))), Undefined()) -> error
    with error := <generate-error(|$[The operator || is undefined for the argument types [t1], [t2]])> e

  pgql-error:
    ExpressionPlusType(aggregation, Undefined()) -> error
    where <?SUM(_, ExpressionPlusType(_, Type(t, _))) +
           ?MIN(_, ExpressionPlusType(_, Type(t, _))) +
           ?MAX(_, ExpressionPlusType(_, Type(t, _))) +
           ?AVG(_, ExpressionPlusType(_, Type(t, _))) +
           ?ARRAY-AGG(_, ExpressionPlusType(_, Type(t, _))) +
           ?JSON-ARRAYAGG(ExpressionPlusType(_, Type(t, _)), _, _, _, _) +
           ?LISTAGG(_, ExpressionPlusType(_, Type(t, _)), _)> aggregation
    with operation := <get-constructor; try(?"ARRAY-AGG"; !"ARRAY_AGG" + ?"JSON-ARRAYAGG"; !"JSON_ARRAYAGG")> aggregation
       ; error := <generate-error(|$[The aggregate [operation] is undefined for the argument type [t]])> aggregation

  // check that WHERE clauses contains boolean expressions
  pgql-error:
    Constraints(constraints) -> error
    where ExpressionPlusType(exp, Type(t, _)) := <remove-all(?ExpressionPlusType(_, Type("BOOLEAN", _))); Hd> constraints
    with error := <generate-error(|$<WHERE clause expects a BOOLEAN but a <t> was given>)> exp

  // check that HAVING clauses contains boolean expressions
  pgql-error:
    HavingClause(ExpressionPlusType(exp, Type(t, _))) -> error
    where <not(?"BOOLEAN")> t
    with error := <generate-error(|$<HAVING clause expects a BOOLEAN but a <t> was given>)> exp

  // check that ORDER BY does not contain vertex/edge/array terms
  pgql-error:
    OrderByElem(ExpressionPlusType(exp, Type(t, _)), _, version) -> error
    where <not(?"v1.0")> version
        ; <?"VERTEX" + ?"EDGE" + string-starts-with(|"ARRAY<") + string-starts-with(|"SET<")> t
    with error := <generate-error(|$[Cannot order by [t]])> exp

  error-duplicate-var-outer-query = !"Duplicate variable (variable with same name is passed from an outer query)"

  pgql-error:
    Vertex(Identifier(v, _), _, Correlation(ExpressionPlusType(VarRef(Identifier(outer-var, _), _), type)), _) -> error
    where <not(?Type("VERTEX", _))> type
    with error := <generate-error(|<error-duplicate-var-outer-query>)> v

  pgql-error:
    Edge(_, Identifier(e, _), _, _, _, Correlation(ExpressionPlusType(VarRef(Identifier(outer-var, _), _), type)), _) -> error
    with error := <generate-error(|<error-duplicate-var-outer-query>)> e

  pgql-error:
    RowsPerMatchVariable(Identifier(v, _), _, Correlation(_), _) -> error
    with error := <generate-error(|<error-duplicate-var-outer-query>)> v

  // check SELECT/COLUMNS clause is not empty (may happen in case of SELECT n.*, COLUMNS ( n.* ) or omitting COLUMNS clause)
  pgql-error:
    t@SelectClause(distinctOrStar, e@SelectList([])) -> error
    where <not(?Star() + ?GroupBySelectStar())> distinctOrStar // for SELECT * (instead of SELECT n.*) with zero columns we already have a different error
    with origin-text := <origin-text; upper-case> t
       ; if <string-starts-with(|"SELECT")> origin-text
         then messsage := "SELECT clause should have at least one column but has zero columns"
         else if <string-starts-with(|"COLUMNS")> origin-text
              then messsage := "COLUMNS clause should have at least one column but has zero columns"
              else if <string-starts-with(|"GRAPH_TABLE")> origin-text
                   then messsage := "GRAPH_TABLE restriction: COLUMNS clause is required"
                   end
              end
         end
       ; error := <generate-error(|messsage)> e

  // SUBSTRING
  pgql-error(|metadata):
    CharacterSubstring(ExpressionPlusType(exp, type@Type(t, _)), _, _) -> error
    where <get-union-type(|metadata); ?AmbiguousType()> (type, <get-default-string-type(|metadata)>)
    with error := <generate-error(|$<Character string expected but a <t> was given>)> exp

  pgql-error(|metadata):
    CharacterSubstring(_, ExpressionPlusType(exp, type@Type(t, _)), _) -> error
    where <get-union-type(|metadata); ?AmbiguousType()> (type, <get-default-long-integer-type(|metadata)>)
    with error := <generate-error(|$<Numeric expected but a <t> was given>)> exp

  pgql-error(|metadata):
    CharacterSubstring(_, _, Some(StringLength(ExpressionPlusType(exp, type@Type(t, _))))) -> error
    where <get-union-type(|metadata); ?AmbiguousType()> (type, <get-default-long-integer-type(|metadata)>)
    with error := <generate-error(|$<Numeric expected but a <t> was given>)> exp

  // function calls
  pgql-error(|metadata):
    ExpressionPlusType(exp@FunctionCall(_, _, _), Undefined()) -> error
    with error := <generate-error(|"Function does not exist or argument types do not match")> exp

  pgql-error(|metadata):
    ExpressionPlusType(exp@FunctionCall(_, _, _), AmbiguousType()) -> error
    with error := <generate-error(|"Multiple functions exist that match the specified function name and argument types")> exp

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("VERTEX_EQUAL", _), [ExpressionPlusType(exp1, t1), _]) -> error
    where <not(?Type("VERTEX", _))> t1
    with error := <generate-error(|"Vertex expected")> exp1

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("VERTEX_EQUAL", _), [_, ExpressionPlusType(exp2, t2)]) -> error
    where <not(?Type("VERTEX", _))> t2
    with error := <generate-error(|"Vertex expected")> exp2

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("EDGE_EQUAL", _), [ExpressionPlusType(exp1, t1), _]) -> error
    where <not(?Type("EDGE", _))> t1
    with error := <generate-error(|"Edge expected")> exp1

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("EDGE_EQUAL", _), [_, ExpressionPlusType(exp2, t2)]) -> error
    where <not(?Type("EDGE", _))> t2
    with error :=<generate-error(|"Edge expected")> exp2

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("VERTEX_ID", _), [ExpressionPlusType(exp, t)]) -> error
    where <not(?Type("VERTEX", _))> t
    with error := <generate-error(|"Vertex expected")> exp

  pgql-error(|metadata):
    FunctionCall(None(), Identifier("EDGE_ID", _), [ExpressionPlusType(exp, t)]) -> error
    where <not(?Type("EDGE", _))> t
    with error := <generate-error(|"Edge expected")> exp

rules

  check-all-restrictions-outside-GraphTable = collect-om(?DerivedTable(Some(GraphTable()), _, _); ![] <+ check-restriction-outside-GraphTable)

  // MATCHNUM outside of GRAPH_TABLE
  check-restriction-outside-GraphTable:
    e@FunctionCall(None(), Identifier("MATCHNUM", _), []) -> error
    with error := <generate-error(|"MATCHNUM without argument not supported unless used inside GRAPH_TABLE")> e

rules // GRAPH_TABLE

  check-all-GraphTable-restrictions:
   ast -> errors
   with if <oncetd(?GraphTable())> ast
        then errors := <collect(check-GraphTable-restriction)> ast
        else errors := []
        end

  check-GraphTable-restriction:
    Vertex(e@Identifier(_, v), _, Correlation(_), _) -> error
    with error := <generate-error(|$<GRAPH_TABLE restriction: vertex sharing between inner and outer query is not allowed, introduce a new variable name like <v>_new and use WHERE vertex_equal(<v>, <v>_new)>)> e

  check-GraphTable-restriction:
    SelectList(elems) -> <not(?[])> errors
    with errors := <filter(?ExpAsVar(ExpressionPlusType(_, Type("VERTEX", _)), _, _, _) + ?ExpAsVar(ExpressionPlusType(_, Type("EDGE", _)), _, _, _)); batch-generate-error(|"GRAPH_TABLE restriction: cannot project vertex or edge objects")> elems

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier(functionName, _), [_]) -> error
    where <?"LABEL" + ?"LABELS"> functionName
    with error := <generate-error(|"GRAPH_TABLE restriction: cannot use label(..) or labels(..), try using the IS LABELED predicate")> e

  check-GraphTable-restriction:
    FunctionCall(None(), Identifier("ALL_DIFFERENT", _), expressionsPlusType) -> <not(?[])> errors
    with nonGraphElements := <filter(not(?ExpressionPlusType(_, Type("VERTEX", _)) + ?ExpressionPlusType(_, Type("EDGE", _))))> expressionsPlusType
       ; errors := <batch-generate-error(|"GRAPH_TABLE restriction: ALL_DIFFERENT predicate allows vertex and edge inputs only")> nonGraphElements

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier("JAVA_REGEXP_LIKE", _), [_, ExpressionPlusType(String(_), _)]) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: JAVA_REGEXP_LIKE is unsupported, please try to use another regexp function if one is available or implement a UDF otherwise")> e

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier("IN_DEGREE", _), [ExpressionPlusType(_, Type("VERTEX", _))]) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: IN_DEGREE not supported, use a subquery instead")> e

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier("OUT_DEGREE", _), [ExpressionPlusType(_, Type("VERTEX", _))]) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: OUT_DEGREE not supported, use a subquery instead")> e

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier("ID", _), [_]) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: ID not supported, use VERTEX_ID or EDGE_ID instead")> e

  check-GraphTable-restriction:
    e@FunctionCall(None(), Identifier("MATCH_NUMBER", _), [_]) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: MATCH_NUMBER not supported, use MATCHNUM instead")> e

  check-GraphTable-restriction:
    e@Eq(ExpressionPlusType(exp1, t1), ExpressionPlusType(exp2, _)) -> error
    where <is-vertex-or-edge-type> t1
    with if <?Type("VERTEX", _)> t1
         then error := <generate-error(|$<GRAPH_TABLE restriction: use VERTEX_EQUAL(<<origin-text> exp1>, <<origin-text> exp2>)>)> e
         else error := <generate-error(|$<GRAPH_TABLE restriction: use EDGE_EQUAL(<<origin-text> exp1>, <<origin-text> exp2>)>)> e
         end

  check-GraphTable-restriction:
    e@Neq(ExpressionPlusType(exp1, t1), ExpressionPlusType(exp2, _)) -> error
    where <is-vertex-or-edge-type> t1
    with if <?Type("VERTEX", _)> t1
         then error := <generate-error(|$<GRAPH_TABLE restriction: use NOT VERTEX_EQUAL(<<origin-text> exp1>, <<origin-text> exp2>)>)> e
         else error := <generate-error(|$<GRAPH_TABLE restriction: use NOT EDGE_EQUAL(<<origin-text> exp1>, <<origin-text> exp2>)>)> e
         end

  check-GraphTable-restriction:
    CommonPathExpressions(pathMacros) -> <not(?[])> errors
    with errors := <map(?CommonPathExpression(<id>, _, _, _, _); generate-error(|"GRAPH_TABLE restriction: path macros not supported"))> pathMacros

  check-GraphTable-restriction:
    e@OneRowPerEdge(_) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: ONE ROW PER EDGE not supported, use ONE ROW PER STEP")> e

  // note: UPDATE and DELETE do not need a check since GRAPH_TABLE does not allow for projecting vertex and edges objects (to be updated/deleted) anyway
  check-GraphTable-restriction:
    e@InsertClause(_, _) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: INSERT not supported")> e

  check-GraphTable-restriction:
    e@ColumnNamePrefix(_) -> error
    with error := <generate-error(|"GRAPH_TABLE restriction: PREFIX not supported")> e

  check-GraphTable-restriction:
    t -> error
    where exp := <get-exp-from-aggregation; (?ExpressionPlusType(_, Type("VERTEX", _)) + ?ExpressionPlusType(_, Type("EDGE", _)))> t
    with error := <generate-error(|"GRAPH_TABLE restriction: aggregation does not allow vertex or edge input; use the vertex/edge identifier or a property instead")> exp

  pgql-error:
    DerivedTable(Some(GraphTable()), Subquery(NormalizedQuery(_, selectClause, _, _, _, CreateOneGroup(), _, _, _, _)), None()) -> <not(?[])> errors
    with aggregations := <collect(is-aggregate)> selectClause
       ; errors := <batch-generate-error(|"COLUMNS clause allows only aggregations that access at least one group variable")> aggregations

rules // OPTIONAL MATCH

  pgql-error:
    GraphPattern(vertices, edges, _, None() /* Match without OPTIONAL keyword */) -> <not(?[])> errors
    with optionallyBoundVertices := <collect(?Vertex(<id>, _, Correlation(ExpressionPlusType(_, Type("VERTEX", [OptionallyBound()]))), _))> (vertices, edges)
       ; errors := <batch-generate-error(|"Variable is optionally bound; use OPTIONAL MATCH")> optionallyBoundVertices
