module trans-for-nabl

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[])
                   + Start-Plhdr() // for empty query string

rules

  trans-query(|variables):
    NormalizedQuery(CommonPathExpressions(pathExpressions), selectOrUpdateClause, optionalGraphName, GraphPattern(vertices, connections, valueExpression), groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        NormalizedQuery(CommonPathExpressions(pathExpressions'), selectOrUpdateClause', optionalGraphName, GraphPattern(vertices', connections'', valueExpression'), groupBy', having', orderBy', limitOffsets, error-messages, version)
    with variables' := <guarantee-size-two-or-more> variables

       // PATH
       ; pathExpressions' := <map(trans-path-expression(|variables'))> pathExpressions

       // FROM + MATCH
       ; (vertices', connections') := <alltd(trans-elem(|variables'))> (vertices, connections)
       ; edges := <filter(?Edge(_, _, _, _, _, _) + path-with-at-most-one-binding)> connections'
       ; paths := <filter(path-with-two-or-more-bindings)> connections'

       ; new-vars := <collect(to-varDef)> (vertices', edges)
       ; new-groupVars := <collect(to-varDef)> paths
       ; <?[x|[y|ys]]> variables'
       ; visible-vars := <replace-or-add-all> (new-vars, x)
       ; visible-groupVars := <replace-or-add-all> (new-groupVars, y)
       ; variables'' := [visible-vars|[visible-groupVars|ys]]

       ; connections'' := <alltd(resolve-var-refs-in-path-expression(|variables''))> connections'

       // only in PGQL 1.2 and up, column names specified in the SELECT clause are visible in GROUP BY, HAVING and ORDER BY (but only outside of aggregations and subqueries)
       ; expAsVars := <(?"v1.0" + ?"v1.1"); ![] <+ !selectOrUpdateClause; ?SelectClause(_, ExpAsVars(<id>)) <+ ![]> version

       // WHERE
       ; valueExpression' := <resolve-where-clause(|variables'', expAsVars)> valueExpression

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectOrUpdateClause; create-one-group(|variables'')) + (!having; ?Some(_))
         then hasGroupBy := True()
            ; (groupBy', variables''') := <resolve-group-by(|variables'', expAsVars)> groupBy
         else hasGroupBy := False()
            ; (groupBy', variables''') := (groupBy, variables'')
         end

       // SELECT / UPDATE
       ; (selectOrUpdateClause', variables'''') := <resolve-select-or-update-clause(|variables''')> selectOrUpdateClause

       // HAVING
       ; having' := <resolve-having(|variables''', variables'''')> having // having resolves to GROUP BY variables first, then to SELECT variables

       // ORDER BY
       ; orderBy' := <resolve-prop-refs(|variables'', hasGroupBy); resolve-var-refs(|variables''''); alltd(optimize-order-by)> orderBy // ORDER BY resolves to SELECT variables first (except in case of a VarRef in a PropRef, which is resolved to FROM first), then to GROUP BY variables

  path-with-at-most-one-binding:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where <has-at-most-one-binding> quantifier

  path-with-two-or-more-bindings:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where not( <has-at-most-one-binding> quantifier )

  guarantee-size-two-or-more = ?[]; ![[], []] <+ ?[x]; ![x, []] <+ id

  trans-elem(|variables):
    Vertex(v) -> Vertex(v, origin-offset, correlation)
    with origin-offset := <origin-offset> v
       ; correlation := <to-Correlation(|variables)> v

  trans-elem(|variables):
    NormalizedEdge(src, e, dst, direction, _, _) -> Edge(src, e, dst, direction, origin-offset, correlation)
    with origin-offset := <origin-offset> e
       ; correlation := <to-Correlation(|variables)> e

  to-Correlation(|variables):
    v -> correlation
    with if <oncetd(?VarDef(v, _, _, _); ?VarDef(v-from-outer-query, origin-position-from-outer-query, _, _))> variables
         then correlation := Correlation(VarRef(v-from-outer-query, origin-position-from-outer-query))
         else correlation := None()
         end

  to-varDef = ?Vertex(name, origin-offset, _); !VarDef(name, origin-offset, None(), None())
  to-varDef = ?Edge(_, name, _, _, origin-offset, _); !VarDef(name, origin-offset, None(), None())

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, _, _, _), varDefs) -> varDefs'
    with if <fetch(?VarDef(v, _, _, _))> varDefs
         then varDefs' := <conc> (<remove-all(?VarDef(v, _, _, _))> varDefs, [vd])
         else varDefs' := <conc> (varDefs, [vd])
         end

  resolve-where-clause(|variables, expAsVars):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|variables, expAsVars)> valueExpression

  resolve-group-by(|variables, expAsVarsFromSelectClause):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), variables')
    with (expAsVars', vars') := <foldl(resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause))> (expAsVars, ([], []))
       ; variables' := [vars'|variables]

  resolve-group-by(|variables, expAsVars):
    None() -> (CreateOneGroup(), variables')
    with vars' := []
       ; variables' := [vars'|variables]

  resolve-select-or-update-clause(|variables):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), variables')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; variables':= variables
         else varsInCurrentScope := <Hd> variables
            ; (expAsVars', vars') := <foldl(resolve-exp-as-var-in-select(|variables))> (expAsVars, ([], varsInCurrentScope))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
            ; variables' := [vars'|<Tl> variables]
         end

  resolve-select-or-update-clause(|variables):
    t@UpdateClause(setPropertyExpressions) -> (updateClause', variables)
    with setPropertyExpressions' := <origin-track-forced(resolve-var-refs(|variables))> setPropertyExpressions
       ; updateClause' := <origin-track-forced(!UpdateClause(setPropertyExpressions'))> t

  resolve-select-or-update-clause(|variables):
    t@InsertClause(graphPattern, intoGraph, setPropertyExpressions) -> (insertClause', variables)
    with setPropertyExpressions' := <origin-track-forced(resolve-var-refs(|variables))> setPropertyExpressions
       ; graphPattern' := <alltd(trans-elem(|[]))> graphPattern
       ; insertClause' := <origin-track-forced(!InsertClause(graphPattern', intoGraph, setPropertyExpressions'))> t

  resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables, expAsVarsFromSelectClause)> exp
       ; exp'' := <alltd(?VarRef(<id>, _); !VarRef(<id>))> exp'
       ; originOffset := <origin-offset> v
       ; vars' := <replace-or-add> (VarDef(v, originOffset, exp'', exp'), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, originOffset))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-exp-as-var-in-select(|variables):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables)> exp
       ; originOffset := <origin-offset> v
       ; vars' := <replace-or-add> (VarDef(v, originOffset, exp, exp'), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, originOffset))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-having(|variables-after-group-by, variables-after-select):
    having -> having'
    with [x|xs] := variables-after-select
       ; [y|_] := variables-after-group-by
       ; z := <replace-or-add-all> (y, x)
       ; variables := [z|xs]
       ; having' := <resolve-var-refs(|variables)> having

  /*
     First try to resolve variables as usual.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) -> (m) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the MATCH clause.
     Only if it fails, try to replace variables with expressions from SELECT before trying to resolve again.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the SELECT clause.
     Note that in the final AST, we only want the SELECT to refer to variables in GROUP BY, even though for the user it typically appears like it's the other way arround.
     For example:
        Actual query: SELECT n.age + 2 FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT (n.age + 2)*(n.age + 2) FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar*generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT n.age + 2 AS v FROM MATCH( (n) ) GROUP BY v
        Final AST:    SELECT v FROM MATCH( (n) ) GROUP BY n.age + 2 AS v
  */
  resolve-var-refs(|variables, expAsVarsFromSelectClause) =
    resolve-var-refs(|variables)
  ; alltd-in-outer-query-outside-aggregation(replace-ref-with-exp(|expAsVarsFromSelectClause))
  ; alltd-in-outer-query-outside-aggregation(resolve-var-ref(|variables))

  resolve-var-refs(|variables) = alltd(resolve-var-ref(|variables))
                               ; alltd(replace-exp-with-ref(|variables) <+ is-subquery <+ is-aggregate)

  resolve-var-refs-in-path-expression(|variables):
    t@Path(_, _, _, quantifier, _, _, _, _) -> t'
    with [_|variables'] := variables
       ; if <has-at-most-one-binding> quantifier
       then t' := <alltd(resolve-var-ref(|variables))> t // resolve only to singleton variables
       else t' := <alltd(resolve-var-ref(|variables') + resolve-var-ref(|variables))> t // resolve to either group variables or singleton variables
        end

  resolve-var-ref(|variables):
    t@VarRef(v) -> varRef
    with varRef := <
        Hd; fetch(?VarDef(v, origin-offset, _, _)); !VarRef(v, origin-offset)
        <+ !VarRef(v)
      > variables

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|variables):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; variables' := <Tl> variables
       ; arguments' :=  <resolve-var-refs(|variables')> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|variables):
    Subquery(query) -> Subquery(query')
    with query' := <trans-query(|variables)> query

  replace-exp-with-ref(|variables):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <Hd; fetch-elem(replace-exp-with-ref-helper(|exp))> variables

  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, original-exp, _); where ( <eq> (exp, original-exp)); !VarRef(v, origin-offset)
  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, _, resolved-exp); where ( <eq> (exp, resolved-exp)); !VarRef(v, origin-offset)

  replace-ref-with-exp(|expAsVars):
    VarRef(v) -> exp
    where ExpAsVar(exp, _, _) := <filter(?ExpAsVar(_, v, NonAnonymous())); Hd> expAsVars

  resolve-prop-refs(|variables, hasGroupBy):
    t -> t'
    with if True() := hasGroupBy
         then t' := t
         else t' := <alltd(resolve-prop-ref(|variables))> t
         end

  resolve-prop-ref(|variables):
    t@PropRef(varRef, prop) -> PropRef(varRef', prop)
    with varRef' := <resolve-var-ref(|variables)> varRef

  /*
     if the query has no GROUP BY but there are one ore more aggregations in the SELECT, then we generate an
     implicit group, but only if there is no (non-nested) aggregation over a group variable
  */
  create-one-group(|variables):
    t@select-or-update-clause -> t
    with [vars|[groupVars|_]] := variables
       ; aggregations := <collect-in-outer-query(is-aggregate)> select-or-update-clause
       ; exps-from-aggregations := <collect(get-exp-from-aggregation)> select-or-update-clause
       ; varsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|vars))> exps-from-aggregations
       ; groupVarsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|groupVars))> exps-from-aggregations
       ; groupVarsInAggregations' := <diff> (groupVarsInAggregations, varsInAggregations)
    where not ( [] := aggregations ) // there are aggregations
        ; [] := groupVarsInAggregations' // but no aggregations that involve group variables (not counting nested aggregations)

  varRef-is-visible-var(|visible-vars):
    t@VarRef(v) -> t
    where <oncetd(?VarDef(v, _, _, _))> visible-vars

  trans-path-expression(|variables):
    CommonPathExpression(name, vertices, edges, valueExpression) -> CommonPathExpression(name, vertices', edges', valueExpression')
    with
       // pattern
        (vertices', edges') := <alltd(trans-elem(|variables))> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; <?[x|xs]> variables
       ; visible-vars := <replace-or-add-all> (new-vars, x)

       // WHERE
       ; variables' := [visible-vars|xs]
       ; valueExpression' := <resolve-where-clause(|variables', [])> valueExpression

  optimize-order-by:
    OrderByClause(elems) -> OrderByClause(elems')
    with elems' := <make-set-while-preserving-ordering> elems // optimization to translate e.g. ORDER BY x, y, x, y into ORDER BY x, y
