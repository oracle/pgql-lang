module trans-for-nabl

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[])
                   + Start-Plhdr() // for empty query string

rules

  trans-query(|variables):
    NormalizedQuery(CommonPathExpressions(pathExpressions), selectClause, optionalGraphName, GraphPattern(vertices, connections, valueExpression), groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        NormalizedQuery(CommonPathExpressions(pathExpressions'), selectClause', optionalGraphName, GraphPattern(vertices', connections'', valueExpression'), groupBy', having', orderBy', limitOffsets, error-messages, version)
    with variables' := <guarantee-size-two-or-more> variables

       // PATH
       ; pathExpressions' := <map(trans-path-expression(|variables'))> pathExpressions

       // FROM + MATCH
       ; (vertices', connections') := <alltd(trans-elem(|variables'))> (vertices, connections)
       ; edges := <filter(?Edge(_, _, _, _, _, _) + path-with-at-most-one-binding)> connections'
       ; paths := <filter(path-with-two-or-more-bindings)> connections'

       ; new-vars := <collect(to-varDef)> (vertices', edges)
       ; new-groupVars := <collect(to-varDef)> paths
       ; <?[x|[y|ys]]> variables'
       ; visible-vars := <replace-or-add-all> (new-vars, x)
       ; visible-groupVars := <replace-or-add-all> (new-groupVars, y)
       ; variables'' := [visible-vars|[visible-groupVars|ys]]

       ; connections'' := <alltd(resolve-var-refs-in-path-expression(|variables''))> connections'

       // only in PGQL 1.2+, column names specified in the SELECT clause are visible in GROUP BY, HAVING and ORDER BY (but only outside of aggregations and subqueries)
       ; expAsVars := <(?"v1.0" + ?"v1.1"); ![] <+ !selectClause; ?SelectClause(_, ExpAsVars(<id>))> version

       // WHERE
       ; valueExpression' := <resolve-where-clause(|variables'', expAsVars)> valueExpression

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectClause; create-one-group(|variables'')) + (!having; ?Some(_))
         then (groupBy', variables''') := <resolve-group-by(|variables'', expAsVars)> groupBy
         else (groupBy', variables''') := (groupBy, variables'')
         end

       // SELECT
       ; (selectClause', variables'''') := <resolve-select-clause(|variables''')> selectClause

       // HAVING
       ; having' := <resolve-var-refs(|variables'''')> having

       // ORDER BY
       ; orderBy' := <resolve-var-refs(|variables''''); alltd(optimize-order-by)> orderBy

  path-with-at-most-one-binding:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where <has-at-most-one-binding> quantifier

  path-with-two-or-more-bindings:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where not( <has-at-most-one-binding> quantifier )

  guarantee-size-two-or-more = ?[]; ![[], []] <+ ?[x]; ![x, []] <+ id

  trans-elem(|variables):
    Vertex(v) -> Vertex(v, origin-offset, correlation)
    with origin-offset := <origin-offset> v
       ; correlation := <to-Correlation(|variables)> v

  trans-elem(|variables):
    NormalizedEdge(src, e, dst, direction, _, _) -> Edge(src, e, dst, direction, origin-offset, correlation)
    with origin-offset := <origin-offset> e
       ; correlation := <to-Correlation(|variables)> e

  to-Correlation(|variables):
    v -> correlation
    with if <oncetd(?VarDef(v, _, _, _); ?VarDef(v-from-outer-query, origin-position-from-outer-query, _, _))> variables
         then correlation := Correlation(VarRef(v-from-outer-query, origin-position-from-outer-query))
         else correlation := None()
         end

  to-varDef = ?Vertex(name, origin-offset, _); !VarDef(name, origin-offset, None(), None())
  to-varDef = ?Edge(_, name, _, _, origin-offset, _); !VarDef(name, origin-offset, None(), None())

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, _, _, _), varDefs) -> varDefs'
    with if <fetch(?VarDef(v, _, _, _))> varDefs
         then varDefs' := <conc> (<remove-all(?VarDef(v, _, _, _))> varDefs, [vd])
         else varDefs' := <conc> (varDefs, [vd])
         end

  resolve-where-clause(|variables, expAsVars):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|variables, expAsVars)> valueExpression

  resolve-group-by(|variables, expAsVarsFromSelectClause):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), variables')
    with (expAsVars', vars') := <foldl(resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause))> (expAsVars, ([], []))
       ; variables' := [vars'|variables]

  resolve-group-by(|variables, expAsVars):
    None() -> (CreateOneGroup(), variables')
    with vars' := []
       ; variables' := [vars'|variables]

  resolve-select-clause(|variables):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), variables')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; variables':= variables
         else (expAsVars', vars') := <foldl(resolve-exp-as-var-in-select(|variables))> (expAsVars, ([], <Hd> variables))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
            ; variables' := [vars'|<Tl> variables]
         end

  resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables, expAsVarsFromSelectClause)> exp
       ; exp'' := <alltd(?VarRef(<id>, _); !VarRef(<id>))> exp'
       ; originOffset := <origin-offset> v
       ; vars' := <replace-or-add> (VarDef(v, originOffset, exp'', exp'), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, originOffset))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-exp-as-var-in-select(|variables):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables)> exp
       ; originOffset := <origin-offset> v
       ; vars' := <replace-or-add> (VarDef(v, originOffset, exp, exp'), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, originOffset))> t
       ; result' := <conc> (result, [expAsVar'])

  /*
     First try to resolve variables as usual.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) -> (m) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the MATCH clause.
     Only if it fails, try to replace variables with expressions from SELECT before trying to resolve again.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the SELECT clause.
     Note that in the final AST, we only want the SELECT to refer to variables in GROUP BY, even though for the user it typically appears like it's the other way arround.
     For example:
        Actual query: SELECT n.age + 2 FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT (n.age + 2)*(n.age + 2) FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar*generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT n.age + 2 AS v FROM MATCH( (n) ) GROUP BY v
        Final AST:    SELECT v FROM MATCH( (n) ) GROUP BY n.age + 2 AS v
  */
  resolve-var-refs(|variables, expAsVarsFromSelectClause) =
    resolve-var-refs(|variables)
  ; alltd-in-outer-query-outside-aggregation(replace-ref-with-exp(|expAsVarsFromSelectClause))
  ; alltd-in-outer-query-outside-aggregation(resolve-var-ref(|variables))

  resolve-var-refs(|variables) = alltd(resolve-var-ref(|variables))
                               ; alltd(replace-exp-with-ref(|variables) <+ is-subquery <+ is-aggregate)

  resolve-var-refs-in-path-expression(|variables):
    t@Path(_, _, _, quantifier, _, _, _, _) -> t'
    with [_|variables'] := variables
       ; if <has-at-most-one-binding> quantifier
       then t' := <alltd(resolve-var-ref(|variables))> t // resolve only to singleton variables
       else t' := <alltd(resolve-var-ref(|variables') + resolve-var-ref(|variables))> t // resolve to either group variables or singleton variables
        end

  resolve-var-ref(|variables):
    t@VarRef(v) -> varRef
    with varRef := <
        Hd; fetch(?VarDef(v, origin-offset, _, _)); !VarRef(v, origin-offset)
        <+ !VarRef(v)
      > variables

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|variables):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; variables' := <Tl> variables
       ; arguments' :=  <resolve-var-refs(|variables')> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|variables):
    Subquery(query) -> Subquery(query')
    with query' := <trans-query(|variables)> query

  replace-exp-with-ref(|variables):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <Hd; fetch-elem(replace-exp-with-ref-helper(|exp))> variables

  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, original-exp, _); where ( <eq> (exp, original-exp)); !VarRef(v, origin-offset)
  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, _, resolved-exp); where ( <eq> (exp, resolved-exp)); !VarRef(v, origin-offset)

  replace-ref-with-exp(|expAsVars):
    VarRef(v) -> exp
    where ExpAsVar(exp, _, _) := <filter(?ExpAsVar(_, v, NonAnonymous())); Hd> expAsVars

  /*
     if the query has no GROUP BY but there are one ore more aggregations in the SELECT, then we generate an
     implicit group, but only if there is no (non-nested) aggregation over a group variable
  */
  create-one-group(|variables):
    t@select-clause -> t
    with [vars|[groupVars|_]] := variables
       ; aggregations := <collect-in-outer-query(is-aggregate)> select-clause
       ; exps-from-aggregations := <collect(get-exp-from-aggregation)> select-clause
       ; varsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|vars))> exps-from-aggregations
       ; groupVarsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|groupVars))> exps-from-aggregations
       ; groupVarsInAggregations' := <diff> (groupVarsInAggregations, varsInAggregations)
    where not ( [] := aggregations ) // there are aggregations
        ; [] := groupVarsInAggregations' // but no aggregations that involve group variables (not counting nested aggregations)

  varRef-is-visible-var(|visible-vars):
    t@VarRef(v) -> t
    where <oncetd(?VarDef(v, _, _, _))> visible-vars

  trans-path-expression(|variables):
    CommonPathExpression(name, vertices, edges, valueExpression) -> CommonPathExpression(name, vertices', edges', valueExpression')
    with
       // pattern
        (vertices', edges') := <alltd(trans-elem(|variables))> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; <?[x|xs]> variables
       ; visible-vars := <replace-or-add-all> (new-vars, x)

       // WHERE
       ; variables' := [visible-vars|xs]
       ; valueExpression' := <resolve-where-clause(|variables', [])> valueExpression

  optimize-order-by:
    OrderByClause(elems) -> OrderByClause(elems')
    with elems' := <make-set-while-preserving-ordering> elems // optimization to translate e.g. ORDER BY x, y, x, y into ORDER BY x, y
