module trans-for-nabl

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[])
                   + Start-Plhdr() // for empty query string

rules

  trans-query(|variables):
    NormalizedQuery(CommonPathExpressions(pathExpressions), selectClause, fromClause, GraphPattern(vertices, connections, valueExpression), groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        NormalizedQuery(CommonPathExpressions(pathExpressions'), selectClause', fromClause, GraphPattern(vertices', connections'', valueExpression'), groupBy', having', orderBy', limitOffsets, error-messages, version)
    with variables' := <guarantee-size-two-or-more> variables

       // PATH
       ; pathExpressions' := <map(trans-path-expression(|variables'))> pathExpressions

       // FROM + MATCH
       ; (vertices', connections') := <alltd(trans-elem(|variables'))> (vertices, connections)
       ; edges := <filter(?Edge(_, _, _, _, _, _) + path-with-at-most-one-binding)> connections'
       ; paths := <filter(path-with-two-or-more-bindings)> connections'

       ; new-vars := <collect(to-varDef)> (vertices', edges)
       ; new-groupVars := <collect(to-varDef)> paths
       ; <?[x|[y|ys]]> variables'
       ; visible-vars := <replace-or-add-all> (new-vars, x)
       ; visible-groupVars := <replace-or-add-all> (new-groupVars, y)
       ; variables'' := [visible-vars|[visible-groupVars|ys]]

       ; connections'' := <alltd(resolve-var-refs-in-path-expression(|variables''))> connections'

       // WHERE
       ; valueExpression' := <resolve-where-clause(|variables'')> valueExpression

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectClause; create-one-group(|variables'')) + (!having; ?Some(_))
         then (groupBy', variables''') := <resolve-group-by(|variables'')> groupBy
         else (groupBy', variables''') := (groupBy, variables'')
         end

       // SELECT
       ; (selectClause', variables'''') := <resolve-select-clause(|variables''')> selectClause

       // HAVING
       ; having' := <resolve-var-refs(|variables'''')> having

       // ORDER BY
       ; orderBy' := <resolve-var-refs(|variables''''); alltd(optimize-order-by)> orderBy

  path-with-at-most-one-binding:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where <has-at-most-one-binding> quantifier

  path-with-two-or-more-bindings:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where not( <has-at-most-one-binding> quantifier )

  guarantee-size-two-or-more = ?[]; ![[], []] <+ ?[x]; ![x, []] <+ id

  trans-elem(|variables):
    Vertex(v) -> Vertex(v, origin-offset, correlation)
    with origin-offset := <origin-offset> v
       ; correlation := <to-Correlation(|variables)> v

  trans-elem(|variables):
    Edge(src, e, dst, direction, _) -> Edge(src, e, dst, direction, origin-offset, correlation)
    with origin-offset := <origin-offset> e
       ; correlation := <to-Correlation(|variables)> e

  to-Correlation(|variables):
    v -> correlation
    with if <oncetd(?VarDef(v, _, _, _); ?VarDef(v-from-outer-query, origin-position-from-outer-query, _, _))> variables
         then correlation := Correlation(VarRef(v-from-outer-query, origin-position-from-outer-query))
         else correlation := None()
         end

  to-varDef = ?Vertex(name, origin-offset, _); !VarDef(name, origin-offset, None(), None())
  to-varDef = ?Edge(_, name, _, _, origin-offset, _); !VarDef(name, origin-offset, None(), None())

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, _, _, _), varDefs) -> varDefs'
    with if <fetch(?VarDef(v, _, _, _))> varDefs
         then varDefs' := <conc> (<remove-all(?VarDef(v, _, _, _))> varDefs, [vd])
         else varDefs' := <conc> (varDefs, [vd])
         end

  resolve-where-clause(|variables):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|variables)> valueExpression

  resolve-group-by(|variables):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), variables')
    with (expAsVars', vars') := <foldl(resolve-exp-as-var(|variables))> (expAsVars, ([], []))
       ; variables' := [vars'|variables]

  resolve-group-by(|variables):
    None() -> (CreateOneGroup(), variables')
    with vars' := []
       ; variables' := [vars'|variables]

  resolve-select-clause(|variables):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), variables')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; variables':= variables
         else (expAsVars', vars') := <foldl(resolve-exp-as-var(|variables))> (expAsVars, ([], <Hd> variables))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
            ; variables' := [vars'|<Tl> variables]
         end

  resolve-exp-as-var(|variables):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables)> exp
       ; vars' := <replace-or-add> (VarDef(v, <origin-offset> v, exp, exp'), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, <origin-offset> v))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-var-refs(|variables) = alltd(resolve-var-ref(|variables))
                               ; alltd-in-outer-query-outside-aggregation(replace-exp-with-ref(|variables))

  resolve-var-refs-in-path-expression(|variables):
    t@Path(_, _, _, quantifier, _, _, _, _) -> t'
    with [_|variables'] := variables
       ; if <has-at-most-one-binding> quantifier
       then t' := <alltd(resolve-var-ref(|variables))> t // resolve only to singleton variables
       else t' := <alltd(resolve-var-ref(|variables') + resolve-var-ref(|variables))> t // resolve to either group variables or singleton variables
        end

  resolve-var-ref(|variables):
    t@VarRef(v) -> varRef
    with varRef := <
        Hd; fetch(?VarDef(v, origin-offset, _, _)); !VarRef(v, origin-offset)
        <+ !VarRef(v)
      > variables

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|variables):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; variables' := <Tl> variables
       ; arguments' :=  <resolve-var-refs(|variables')> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|variables):
    Subquery(query) -> Subquery(query')
    with query' := <trans-query(|variables)> query

  replace-exp-with-ref(|variables):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <Hd; fetch-elem(replace-exp-with-ref-helper(|exp))> variables

  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, original-exp, _); where ( <eq> (exp, original-exp)); !VarRef(v, origin-offset)
  replace-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, _, resolved-exp); where ( <eq> (exp, resolved-exp)); !VarRef(v, origin-offset)

  /* if the query has no GROUP BY but there are one ore more aggregations in the SELECT, then we generate an
     implicit group, but only if there is no (non-nested) aggregation over a group variable
  */
  create-one-group(|variables):
    t@select-clause -> t
    with [vars|[groupVars|_]] := variables
       ; aggregations := <collect-in-outer-query(is-aggregate)> select-clause
       ; exps-from-aggregations := <collect(get-exp-from-aggregation)> select-clause
       ; varsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|vars))> exps-from-aggregations
       ; groupVarsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|groupVars))> exps-from-aggregations
       ; groupVarsInAggregations' := <diff> (groupVarsInAggregations, varsInAggregations)
    where not ( [] := aggregations ) // there are aggregations
        ; [] := groupVarsInAggregations' // but no aggregations that involve group variables (not counting nested aggregations)

  varRef-is-visible-var(|visible-vars):
    t@VarRef(v) -> t
    where <oncetd(?VarDef(v, _, _, _))> visible-vars

  trans-path-expression(|variables):
    CommonPathExpression(name, vertices, edges, valueExpression) -> CommonPathExpression(name, vertices', edges', valueExpression')
    with
       // pattern
        (vertices', edges') := <alltd(trans-elem(|variables))> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; <?[x|xs]> variables
       ; visible-vars := <replace-or-add-all> (new-vars, x)

       // WHERE
       ; variables' := [visible-vars|xs]
       ; valueExpression' := <resolve-where-clause(|variables')> valueExpression

  optimize-order-by:
    OrderByClause(elems) -> OrderByClause(elems')
    with elems' := <make-set-while-preserving-ordering> elems // optimization to translate e.g. ORDER BY x, y, x, y into ORDER BY x, y
